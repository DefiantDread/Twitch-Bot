This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-04T23:15:49.741Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
check_tables.py
checker.py
config/config.py
core/bot.py
core/raid_channel_points.py
core/raid_cleanup.py
core/raid_command_validator.py
core/raid_errors.py
core/raid_manager.py
core/raid_messages.py
core/raid_points.py
core/raid_recovery.py
core/raid_rewards.py
core/raid_scheduler.py
core/raid_states.py
core/raid_validation.py
core/rewards.py
database/manager.py
database/models.py
features/analytics/tracker.py
features/commands/analytics.py
features/commands/base.py
features/commands/mod_commands.py
features/commands/raid_commands.py
features/commands/rewards.py
features/moderation/moderator.py
features/moderation/timeout_manager.py
features/points/commands.py
features/points/points_manager.py
features/raids/__init__.py
features/raids/commands.py
features/raids/message_handler.py
features/rewards/base_handler.py
features/rewards/basic_rewards.py
features/rewards/handlers.py
features/rewards/moderation.py
features/rewards/rewards.py
features/rewards/stream_interaction.py
features/tracking/user_tracker.py
main.py
pytest.ini
requirements-test.txt
requirements.txt
run_tests.py
tests/__init__.py
tests/conftest.py
tests/test_analytics.py
tests/test_cache.py
tests/test_command_storage.py
tests/test_command_usage.py
tests/test_database_cache.py
tests/test_database_pool.py
tests/test_database.py
tests/test_error_recovery.py
tests/test_raid_points.py
tests/test_raid_rewards.py
tests/test_raid_system.py
tests/test_rate_limiting.py
tests/test_rewards.py
tests/test_stream_analytics.py
tests/test_user_storage.py
utils/alert_system.py
utils/cache_manager.py
utils/db_health.py
utils/decorators.py
utils/error_tracking.py
utils/health_checker.py
utils/monitoring.py
utils/performance_monitor.py
utils/query_profiler.py
utils/rate_limiter.py

================================================================
Repository Files
================================================================

================
File: check_tables.py
================
import sqlite3

# Path to your database file
db_path = "bot.db"  # Replace with your actual database path

try:
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # Create the `users` table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            twitch_id TEXT UNIQUE NOT NULL,
            username TEXT NOT NULL,
            is_mod BOOLEAN DEFAULT FALSE,
            is_subscriber BOOLEAN DEFAULT FALSE,
            first_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
    ''')
    conn.commit()
    print("`users` table created successfully.")

except Exception as e:
    print("Error creating `users` table:", e)
finally:
    conn.close()

================
File: checker.py
================
import os
import re

def find_sql_and_utcnow_occurrences(base_path):
    """
    Recursively search for raw SQL queries and utcnow occurrences in Python files in the specified directory.
    """
    sql_patterns = [
        re.compile(r'execute\((["\'])(.*?)\1'),  # Captures queries passed to execute()
        re.compile(r'query\((["\'])(.*?)\1'),    # Captures queries passed to query()
    ]
    utcnow_pattern = re.compile(r'\bdatetime\.utcnow\(\)')  # Captures datetime.utcnow()

    occurrences = {
        'sql': [],
        'utcnow': []
    }

    for root, _, files in os.walk(base_path):
        for file in files:
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()

                    # Search for SQL queries
                    """for pattern in sql_patterns:
                        for match in pattern.finditer(content):
                            query = match.group(2)
                            line_number = content[:match.start()].count('\n') + 1
                            occurrences['sql'].append({
                                'file': file_path,
                                'line': line_number,
                                'query': query.strip()
                            })"""

                    # Search for datetime.utcnow()
                    for match in utcnow_pattern.finditer(content):
                        line_number = content[:match.start()].count('\n') + 1
                        occurrences['utcnow'].append({
                            'file': file_path,
                            'line': line_number,
                            'expression': match.group(0)
                        })

    return occurrences


if __name__ == "__main__":
    base_dir = input("Enter the path to your project directory: ")
    results = find_sql_and_utcnow_occurrences(base_dir)

    if results['sql']:
        print(f"Found {len(results['sql'])} raw SQL query occurrences:")
        for result in results['sql']:
            print(f"File: {result['file']}, Line: {result['line']}, Query: {result['query']}")
    else:
        print("No raw SQL queries found.")

    if results['utcnow']:
        print(f"\nFound {len(results['utcnow'])} occurrences of datetime.utcnow():")
        for result in results['utcnow']:
            print(f"File: {result['file']}, Line: {result['line']}, Expression: {result['expression']}")
    else:
        print("No occurrences of datetime.utcnow() found.")

================
File: config/config.py
================
# config/config.py
import os
from dotenv import load_dotenv

load_dotenv()

class Config:
    # Bot Configuration
    BOT_TOKEN = os.getenv('TWITCH_BOT_TOKEN')
    CLIENT_ID = os.getenv('TWITCH_CLIENT_ID')
    CLIENT_SECRET = os.getenv('TWITCH_CLIENT_SECRET')
    BOT_PREFIX = os.getenv('BOT_PREFIX', '!')
    CHANNEL_NAME = os.getenv('CHANNEL_NAME')
    
    # Database Configuration
    DATABASE_URL = os.getenv('DATABASE_URL', 'sqlite:///bot.db')
    
    # Feature Flags
    ENABLE_MODERATION = os.getenv('ENABLE_MODERATION', 'True').lower() == 'true'
    ENABLE_CUSTOM_COMMANDS = os.getenv('ENABLE_CUSTOM_COMMANDS', 'True').lower() == 'true'
    
    # Moderation Settings
    MAX_MESSAGE_LENGTH = int(os.getenv('MAX_MESSAGE_LENGTH', 500))
    LINK_PROTECTION = os.getenv('LINK_PROTECTION', 'True').lower() == 'true'
    
    @classmethod
    def validate(cls):
        """Validate that all required configuration is present"""
        required_fields = ['BOT_TOKEN', 'CLIENT_ID', 'CLIENT_SECRET', 'CHANNEL_NAME']
        missing_fields = [field for field in required_fields if not getattr(cls, field)]
        
        if missing_fields:
            raise ValueError(f"Missing required configuration: {', '.join(missing_fields)}")

================
File: core/bot.py
================
# core/bot.py
from asyncio.log import logger
import logging
import asyncio
from sqlalchemy import text
from twitchio.ext import commands
from datetime import datetime, timezone
from config.config import Config
from core.raid_manager import RaidManager
from core.raid_messages import RaidMessageHandler
from core.raid_recovery import RaidRecoveryManager
from core.raid_scheduler import RaidScheduler
from core.rewards import RewardManager
from database.manager import DatabaseManager
from features.analytics.tracker import AnalyticsTracker
from features.commands.analytics import AnalyticsCommands
from features.commands.mod_commands import ModCommands
from features.commands.raid_commands import RaidCommands
from features.moderation.timeout_manager import TimeoutManager
from features.points.points_manager import PointsManager
from features.points.commands import PointsCommands
from features.rewards.handlers import RewardHandlers
from features.rewards.moderation import ModerationRewardHandler
from features.rewards.stream_interaction import StreamInteractionHandler
from utils.decorators import error_boundary
from utils.rate_limiter import RateLimiter
from utils.health_checker import HealthChecker
from utils.monitoring import PerformanceMonitor, TimingContext
from utils.alert_system import AlertManager
from features.tracking.user_tracker import UserTracker
from features.moderation.moderator import ModerationManager
from features.commands.base import BaseCommands

class TwitchBot(commands.Bot):
    def __init__(self):
        super().__init__(
            token=Config.BOT_TOKEN,
            prefix=Config.BOT_PREFIX,
            initial_channels=[Config.CHANNEL_NAME]
        )
        
        # Store channel name for easy access
        self.channel_name = Config.CHANNEL_NAME
        
        # Initialize raid system components
        self.raid_messages = RaidMessageHandler(self)
        self.raid_manager = RaidManager(self)
        self.raid_recovery = RaidRecoveryManager(self)
        self.raid_scheduler = RaidScheduler(self)

        # Add to existing background_tasks setup
        self._raid_check_task = None  # For periodic raid spawning

        # Store prefix for easy access
        self.command_prefix = Config.BOT_PREFIX

        # Initialize monitoring and analytics components
        self.monitor = PerformanceMonitor(self)
        self.timeout_manager = TimeoutManager()
        self.analytics = AnalyticsTracker(self)
        self.health_checker = HealthChecker(self)

        # Initialize user and raid tracking
        self.user_tracker = UserTracker(self)
        self.moderation = ModerationManager(self)
        self.points_manager = PointsManager(self)

        # Initialize rewards and moderation
        self.rewards = RewardManager(self)
        self.reward_handler = RewardHandlers(self)
        self.moderation_rewards = ModerationRewardHandler(self)
        self.stream_interaction = StreamInteractionHandler(self)

        # Initialize rate limiter and alert manager
        self.rate_limiter = RateLimiter()
        self.alert_manager = AlertManager(self)

        # Initialize database manager
        self.db = DatabaseManager()

        # Set up logging
        self.logger = logging.getLogger('bot')

        # Track bot state information
        self.start_time = datetime.now(timezone.utc)
        self.stream_start_time = None
        self.messages_count = 0
        self.background_tasks = set()

        # Initialize cogs
        self._register_cogs()
        self._register_reward_handlers()
        self.setup_alert_handlers()

        # Start background monitoring
        self._start_background_tasks()

    @property
    def prefix(self):
        """Return the command prefix"""
        return self.command_prefix
    
    def _register_cogs(self):
        """Register all cogs"""
        try:
            if 'BaseCommands' not in self.cogs:
                self.add_cog(BaseCommands(self))
            if 'AnalyticsCommands' not in self.cogs:
                self.add_cog(AnalyticsCommands(self))
            if 'PointsCommands' not in self.cogs:
                self.add_cog(PointsCommands(self))
            if 'RaidCommands' not in self.cogs:
                self.add_cog(RaidCommands(self))
            if 'ModCommands' not in self.cogs:
                self.add_cog(ModCommands(self))
                
        except Exception as e:
            self.logger.error(f"Error registering cogs: {e}")

    async def event_message(self, message):
        if message.echo:
            return

        try:
            # Process commands if message starts with prefix
            if message.content.startswith(self.prefix):
                await self.handle_commands(message)
            
            # Track user activity
            await self.user_tracker.track_user_message(message)
            
            # Update analytics
            self.messages_count += 1
            
        except Exception as e:
            logger.error(f"Error processing message: {e}")

    async def handle_commands(self, message):
        """Process commands"""
        try:
            ctx = await self.get_context(message)
            await self.invoke(ctx)
        except Exception as e:
            logger.error(f"Error handling command: {e}")

    async def event_ready(self):
        """Called when bot is ready"""
        logger.info(f"Bot is ready! Username: {self.nick}")
        
        # Load moderation settings
        await self.moderation.load_banned_phrases()
        await self.points_manager.setup()
        
        # Add commands
        if not self.cogs:
            self.add_cog(BaseCommands(self))
            self.add_cog(AnalyticsCommands(self))
            self.add_cog(PointsCommands(self))
            self.add_cog(RaidCommands(self))
            self.add_cog(ModCommands(self))

    async def get_viewer_count(self) -> int:
        try:
            channel = await self.fetch_channel(Config.CHANNEL_NAME)
            if hasattr(channel, 'viewer_count'):
                return channel.viewer_count
            else:
                logger.error("Viewer count attribute not available.")
                return 0
        except Exception as e:
            logger.error(f"Error getting viewer count: {e}")
            return 0    

    def _register_reward_handlers(self):
        """Register all reward handlers with their respective IDs"""
        handlers = {
            **self.stream_interaction.handlers,
            **self.moderation_rewards.handlers
        }
        
        for reward_id, handler in handlers.items():
            self.rewards.register_reward(reward_id, handler)

    def _start_background_tasks(self):
        """Initialize background tasks"""
        tasks = [
            self._update_watch_time(),
            self._cleanup_inactive_users(),
            self._update_analytics()
        ]
        
        for task in tasks:
            task_obj = asyncio.create_task(task)
            self.background_tasks.add(task_obj)
            task_obj.add_done_callback(self.background_tasks.discard)

    async def _update_watch_time(self):
        """Background task to update user watch time"""
        while True:
            try:
                await self.user_tracker.update_watch_time()
                await asyncio.sleep(60)  # Update every minute
            except asyncio.CancelledError:
                # This is expected if the task is canceled, e.g., during shutdown
                logger.info("Watch time update task was cancelled.")
                raise
            except (RuntimeError, ValueError) as e:
                # Handle specific, known errors that might occur
                logger.error("Known error in watch time update task: %s", e, exc_info=True)
                # Optionally, you might want to implement a retry mechanism here
            except Exception as e:
                # Catch any unexpected exceptions, log them
                logger.error("Unexpected error in watch time update task: %s", e, exc_info=True)
                # Wait before retrying to avoid a fast crash-restart loop
                await asyncio.sleep(5)

    async def _cleanup_inactive_users(self):
        """Background task to cleanup inactive users"""
        try:
            while True:
                await self.user_tracker.cleanup_inactive_users()
                await asyncio.sleep(300)  # Check every 5 minutes
        except Exception as e:
            logger.error("Error in user cleanup task: %s", e)

    async def _update_analytics(self):
        """Background task to update analytics"""
        try:
            while True:
                stats = await self.user_tracker.get_session_stats()
                await self.analytics.update_session_stats(stats)
                await asyncio.sleep(300)  # Update every 5 minutes
        except Exception as e:
            logger.error("Error in analytics update task: %s", e)

    async def event_stream_start(self):
        """Called when the stream starts."""
        self.stream_start_time = datetime.now(timezone.utc)
        task = asyncio.create_task(self._periodic_stats_update())
        self.background_tasks.add(task)
        task.add_done_callback(self.background_tasks.discard)

    async def event_stream_end(self):
        """Called when the stream ends."""
        if self.stream_start_time:
            duration = int((datetime.now(timezone.utc) - self.stream_start_time).total_seconds() / 60)
            try:
                # Update final stream stats
                async with self.db.session_scope() as session:
                    # Use text() for the query to ensure async compatibility
                    result = await session.execute(
                        text("""
                            SELECT * FROM stream_stats 
                            ORDER BY id DESC LIMIT 1
                        """)
                    )
                    stats = result.first()
                    
                    if stats:
                        await session.execute(
                            text("""
                                UPDATE stream_stats 
                                SET stream_duration = :duration, 
                                    messages_sent = :messages_count
                                WHERE id = :id
                            """),
                            {
                                'duration': duration,
                                'messages_count': self.messages_count,
                                'id': stats[0]  # Assuming id is the first column
                            }
                        )
                        await session.commit()
                        
            except Exception as e:
                self.logger.error(f"Failed to update final stream stats: {e}")

    async def _periodic_stats_update(self):
        """Background task to periodically update stream stats"""
        try:
            while True:
                await self.db.stream_stats_manager.flush()
                await asyncio.sleep(30)  # Update every 30 seconds
        except asyncio.CancelledError:
            # Make sure we save stats one last time if the task is cancelled
            await self.db.stream_stats_manager.flush()

    def setup_alert_handlers(self):
        """Setup default alert handlers"""
        # Add Discord webhook handler if configured
        if hasattr(Config, 'DISCORD_WEBHOOK_URL'):
            self.alert_manager.add_alert_handler(self.discord_alert_handler)
        
        # Add Twitch chat handler for important alerts
        self.alert_manager.add_alert_handler(self.chat_alert_handler)

    async def discord_alert_handler(self, alert):
        """Send important alerts to Discord"""
        if alert['severity'].value in ['warning', 'critical']:
            # Implementation of Discord webhook...
            pass

    async def chat_alert_handler(self, alert):
        """Send critical alerts to Twitch chat"""
        if alert['severity'].value == 'critical':
            await self.get_channel(Config.CHANNEL_NAME).send(
                f"⚠️ Bot Health Alert: {alert['message']}"
            )

    async def send_chat_message(self, message: str):
        """Send a message to the channel"""
        try:
            channel = self.get_channel(self.channel_name)
            if channel:
                await channel.send(message)
            else:
                logger.error(f"Could not find channel: {self.channel_name}")
        except Exception as e:
            logger.error(f"Error sending chat message: {e}", exc_info=True)

    def handle_signal(self, signum, frame):
        """Handle system signals for graceful shutdown"""
        logger.info(f"Received signal {signum}, initiating shutdown...")
        asyncio.create_task(self.close())

    async def close(self):
        """Cleanup when shutting down"""
        try:
            logger.info("Bot shutting down, cleaning up...")
            
            # Cancel background tasks
            for task in self.background_tasks:
                if not task.done():
                    task.cancel()
            
            # Wait for tasks to complete with timeout
            if self.background_tasks:
                done, pending = await asyncio.wait(self.background_tasks, timeout=5)
                for task in pending:
                    logger.warning(f"Task {task} did not complete in time")

            # Ensure raid system is properly cleaned up
            if hasattr(self, 'raid_manager'):
                try:
                    await self.raid_manager._reset_raid_data()
                except Exception as e:
                    logger.error(f"Error cleaning up raid manager: {e}")
            
            # Final analytics update
            try:
                stats = await self.user_tracker.get_session_stats()
                await self.analytics.update_session_stats(stats)
            except Exception as e:
                logger.error(f"Error updating final stats: {e}")
            
            # Close database connections
            try:
                await self.db.close()
            except Exception as e:
                logger.error(f"Error closing database: {e}")
            
        except Exception as e:
            logger.error(f"Error during shutdown: {e}")
        finally:
            await super().close()

================
File: core/raid_channel_points.py
================
# core/raid_channel_points.py

import logging
from typing import Dict, Optional, List
from dataclasses import dataclass
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

@dataclass
class RaidReward:
    id: str
    name: str
    cost: int
    description: str
    cooldown: int  # seconds
    is_enabled: bool = True
    
@dataclass
class RewardEffect:
    multiplier: float
    duration: int  # seconds
    stack: bool = False

class RaidRewardManager:
    def __init__(self, bot):
        self.bot = bot
        self._active_effects: Dict[str, List[RewardEffect]] = {}
        self.rewards = self._setup_rewards()
        
    def _setup_rewards(self) -> Dict[str, RaidReward]:
        return {
            'boost_multiplier': RaidReward(
                id='raid_multiplier_boost',
                name='Boost Raid Multiplier',
                cost=5000,
                description='Increases raid multiplier by 0.2x for 60 seconds',
                cooldown=300
            ),
            'extend_time': RaidReward(
                id='raid_time_extension',
                name='Extend Raid Time',
                cost=3000,
                description='Adds 30 seconds to the current raid phase',
                cooldown=180
            ),
            'double_investment': RaidReward(
                id='double_investment',
                name='Double Investment Power',
                cost=8000,
                description='Next investment counts double towards raid progress',
                cooldown=600
            ),
            'instant_milestone': RaidReward(
                id='instant_milestone',
                name='Trigger Milestone',
                cost=10000,
                description='Instantly triggers next raid milestone if requirements are met',
                cooldown=900
            ),
            'bonus_plunder': RaidReward(
                id='bonus_plunder',
                name='Bonus Plunder',
                cost=7000,
                description='Adds 20% bonus plunder to final raid rewards',
                cooldown=600
            )
        }

    async def handle_reward_redemption(
        self,
        reward_id: str,
        user_id: str,
        raid_instance
    ) -> bool:
        """Handle channel point reward redemption"""
        try:
            if reward_id not in self.rewards:
                return False
                
            reward = self.rewards[reward_id]
            if not reward.is_enabled:
                return False

            # Handle specific rewards
            if reward_id == 'boost_multiplier':
                return await self._handle_multiplier_boost(raid_instance)
            elif reward_id == 'extend_time':
                return await self._handle_time_extension(raid_instance)
            elif reward_id == 'double_investment':
                return await self._handle_double_investment(user_id)
            elif reward_id == 'instant_milestone':
                return await self._handle_instant_milestone(raid_instance)
            elif reward_id == 'bonus_plunder':
                return await self._handle_bonus_plunder(raid_instance)
                
            return False

        except Exception as e:
            logger.error(f"Error handling reward redemption: {e}")
            return False

    async def _handle_multiplier_boost(self, raid_instance) -> bool:
        """Handle multiplier boost reward"""
        try:
            if raid_instance.state not in ['RECRUITING', 'MILESTONE']:
                return False
                
            effect = RewardEffect(
                multiplier=0.2,
                duration=60,
                stack=True
            )
            
            raid_instance.current_multiplier += effect.multiplier
            self._add_effect('multiplier_boost', effect)
            
            await self.bot.raid_messages.announce_reward_effect(
                f"Raid multiplier increased by 0.2x! "
                f"Current multiplier: {raid_instance.current_multiplier}x"
            )
            
            return True

        except Exception as e:
            logger.error(f"Error handling multiplier boost: {e}")
            return False

    async def _handle_time_extension(self, raid_instance) -> bool:
        """Handle time extension reward"""
        try:
            if raid_instance.state not in ['RECRUITING', 'MILESTONE']:
                return False
                
            # Add 30 seconds to current phase
            raid_instance.extend_time(30)
            
            await self.bot.raid_messages.announce_reward_effect(
                "Raid time extended by 30 seconds!"
            )
            
            return True

        except Exception as e:
            logger.error(f"Error handling time extension: {e}")
            return False

    async def _handle_double_investment(self, user_id: str) -> bool:
        """Handle double investment reward"""
        try:
            effect = RewardEffect(
                multiplier=2.0,
                duration=120,  # 2 minutes to use it
                stack=False
            )
            
            self._add_effect(f'double_investment_{user_id}', effect)
            
            await self.bot.raid_messages.announce_reward_effect(
                f"@{user_id} next investment will count double! "
                f"Valid for 2 minutes."
            )
            
            return True

        except Exception as e:
            logger.error(f"Error handling double investment: {e}")
            return False

    async def _handle_instant_milestone(self, raid_instance) -> bool:
        """Handle instant milestone reward"""
        try:
            if raid_instance.state not in ['RECRUITING']:
                return False
                
            milestone = raid_instance.check_milestone()
            if not milestone:
                return False
                
            raid_instance.trigger_milestone(milestone)
            
            await self.bot.raid_messages.announce_reward_effect(
                f"Raid milestone triggered! New multiplier: {raid_instance.current_multiplier}x"
            )
            
            return True

        except Exception as e:
            logger.error(f"Error handling instant milestone: {e}")
            return False

    async def _handle_bonus_plunder(self, raid_instance) -> bool:
        """Handle bonus plunder reward"""
        try:
            effect = RewardEffect(
                multiplier=1.2,
                duration=None,  # Lasts until raid end
                stack=False
            )
            
            self._add_effect('bonus_plunder', effect)
            
            await self.bot.raid_messages.announce_reward_effect(
                "20% bonus plunder will be added to final rewards!"
            )
            
            return True

        except Exception as e:
            logger.error(f"Error handling bonus plunder: {e}")
            return False

    def _add_effect(self, effect_id: str, effect: RewardEffect):
        """Add an active effect"""
        if effect_id not in self._active_effects:
            self._active_effects[effect_id] = []
            
        if effect.stack or not self._active_effects[effect_id]:
            self._active_effects[effect_id].append(effect)

    async def check_effects(self) -> None:
        """Check and clean up expired effects"""
        current_time = datetime.now()
        
        for effect_id, effects in list(self._active_effects.items()):
            # Remove expired effects
            self._active_effects[effect_id] = [
                effect for effect in effects
                if not effect.duration or (
                    hasattr(effect, 'start_time') and
                    current_time - effect.start_time < timedelta(seconds=effect.duration)
                )
            ]
            
            # Remove empty effect lists
            if not self._active_effects[effect_id]:
                del self._active_effects[effect_id]

    def get_active_effects(self) -> Dict[str, List[RewardEffect]]:
        """Get currently active effects"""
        return self._active_effects.copy()

    async def cleanup(self) -> None:
        """Clean up all effects"""
        self._active_effects.clear()

================
File: core/raid_cleanup.py
================
# core/raid_cleanup.py

import logging
import asyncio
from datetime import datetime, timezone, timedelta
from typing import List, Dict, Optional
from sqlalchemy import text

logger = logging.getLogger(__name__)

class RaidCleanupManager:
    def __init__(self, bot):
        self.bot = bot
        self.is_running = False
        self._task: Optional[asyncio.Task] = None
        self.cleanup_interval = 300  # 5 minutes
        self.raid_timeout = 300      # 5 minutes
        self.history_retention = 30   # days
        
        # Success criteria for auto-completion
        self.min_participants = 2
        self.min_investment = 500

    async def start(self):
        """Start the cleanup system"""
        if self.is_running:
            return

        self.is_running = True
        self._task = asyncio.create_task(self._cleanup_loop())
        logger.info("Raid cleanup system started")

    async def stop(self):
        """Stop the cleanup system"""
        self.is_running = False
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
        logger.info("Raid cleanup system stopped")

    async def _cleanup_loop(self):
        """Main cleanup loop"""
        while self.is_running:
            try:
                # Check for abandoned raids
                await self._cleanup_abandoned_raids()
                
                # Clean up old raid history
                await self._cleanup_raid_history()
                
                # Optimize database tables
                await self._optimize_tables()
                
                await asyncio.sleep(self.cleanup_interval)
                
            except Exception as e:
                logger.error(f"Error in cleanup loop: {e}")
                await asyncio.sleep(60)

    async def _cleanup_abandoned_raids(self):
        """Clean up abandoned or stuck raids"""
        try:
            current_raid = self.bot.raid_manager.current_raid
            if not current_raid:
                return

            elapsed = (datetime.now(timezone.utc) - current_raid.start_time).total_seconds()
            
            # Handle different abandoned states
            if elapsed > self.raid_timeout:
                if len(current_raid.participants) >= self.min_participants:
                    # Auto-complete raid if it has enough participation
                    logger.info("Auto-completing timed out raid with sufficient participation")
                    await self._auto_complete_raid(current_raid)
                else:
                    # Cancel and refund raid if insufficient participation
                    logger.info("Canceling timed out raid with insufficient participation")
                    await self._cancel_raid(current_raid, "Raid timed out")

        except Exception as e:
            logger.error(f"Error cleaning up abandoned raids: {e}")

    async def _cleanup_raid_history(self):
        """Clean up old raid history records"""
        try:
            async with self.bot.db.session_scope() as session:
                cutoff = datetime.now(timezone.utc) - timedelta(days=self.history_retention)
                
                # Archive old raids to history table
                await session.execute(
                    text("""
                        INSERT INTO raid_history_archive
                        SELECT *
                        FROM raid_history
                        WHERE end_time < :cutoff
                    """),
                    {'cutoff': cutoff}
                )
                
                # Remove old raids from main table
                await session.execute(
                    text("""
                        DELETE FROM raid_history
                        WHERE end_time < :cutoff
                    """),
                    {'cutoff': cutoff}
                )
                
                # Clean up related tables
                await session.execute(
                    text("""
                        DELETE FROM raid_participants
                        WHERE raid_id NOT IN (
                            SELECT id FROM raid_history
                        )
                    """)
                )
                
                await session.commit()
                
        except Exception as e:
            logger.error(f"Error cleaning up raid history: {e}")

    async def _optimize_tables(self):
        """Optimize database tables periodically"""
        try:
            async with self.bot.db.session_scope() as session:
                # Update statistics for better query planning
                await session.execute(text("ANALYZE raid_history"))
                await session.execute(text("ANALYZE raid_participants"))
                await session.execute(text("ANALYZE player_raid_stats"))
                
                # Remove duplicate entries if any
                await session.execute(
                    text("""
                        DELETE FROM player_raid_stats
                        WHERE rowid NOT IN (
                            SELECT MIN(rowid)
                            FROM player_raid_stats
                            GROUP BY user_id
                        )
                    """)
                )
                
                await session.commit()
                
        except Exception as e:
            logger.error(f"Error optimizing tables: {e}")

    async def _auto_complete_raid(self, raid_instance) -> bool:
        """Auto-complete a raid that has sufficient participation"""
        try:
            # Calculate rewards
            rewards = raid_instance.get_rewards()
            
            # Distribute rewards
            success = await self.bot.raid_rewards_manager.distribute_rewards(raid_instance)
            if not success:
                await self._cancel_raid(raid_instance, "Failed to distribute rewards")
                return False
            
            # Update raid record
            async with self.bot.db.session_scope() as session:
                await session.execute(
                    text("""
                        UPDATE raid_history
                        SET end_time = :end_time,
                            status = 'auto_completed',
                            total_plunder = :total_plunder
                        WHERE start_time = :start_time
                    """),
                    {
                        'end_time': datetime.now(timezone.utc),
                        'total_plunder': sum(rewards.values()),
                        'start_time': raid_instance.start_time
                    }
                )
                await session.commit()
            
            return True
            
        except Exception as e:
            logger.error(f"Error auto-completing raid: {e}")
            return False

    async def _cancel_raid(self, raid_instance, reason: str) -> bool:
        """Cancel a raid and refund participants"""
        try:
            # Process refunds
            refunds = {
                user_id: participant.total_investment
                for user_id, participant in raid_instance.participants.items()
            }
            
            success = await self.bot.raid_points_manager.batch_refund(refunds, reason)
            if not success:
                logger.error("Failed to process refunds for canceled raid")
                return False
            
            # Update raid record
            async with self.bot.db.session_scope() as session:
                await session.execute(
                    text("""
                        UPDATE raid_history
                        SET end_time = :end_time,
                            status = 'canceled',
                            notes = :reason
                        WHERE start_time = :start_time
                    """),
                    {
                        'end_time': datetime.now(timezone.utc),
                        'reason': reason,
                        'start_time': raid_instance.start_time
                    }
                )
                await session.commit()
            
            # Reset raid state
            self.bot.raid_manager.current_raid = None
            self.bot.raid_manager.state = 'INACTIVE'
            
            return True
            
        except Exception as e:
            logger.error(f"Error canceling raid: {e}")
            return False

    async def get_cleanup_stats(self) -> Dict:
        """Get statistics about cleanup operations"""
        try:
            async with self.bot.db.session_scope() as session:
                # Get counts of different raid outcomes
                result = await session.execute(
                    text("""
                        SELECT 
                            status,
                            COUNT(*) as count,
                            AVG(total_plunder) as avg_plunder
                        FROM raid_history
                        WHERE end_time > :cutoff
                        GROUP BY status
                    """),
                    {'cutoff': datetime.now(timezone.utc) - timedelta(days=7)}
                )
                stats = await result.fetchall()
                
                return {
                    'raid_outcomes': {
                        row[0]: {
                            'count': row[1],
                            'avg_plunder': row[2]
                        } for row in stats
                    },
                    'last_cleanup': datetime.now(timezone.utc),
                    'history_retention_days': self.history_retention
                }
                
        except Exception as e:
            logger.error(f"Error getting cleanup stats: {e}")
            return {}

================
File: core/raid_command_validator.py
================
# core/raid_command_validator.py

from datetime import datetime, timezone
from typing import Tuple, Optional
from core.raid_errors import ErrorCode, ValidationError
from utils.rate_limiter import RateLimiter
import logging

logger = logging.getLogger(__name__)

class RaidCommandValidator:
    def __init__(self, bot):
        self.bot = bot
        self.rate_limiter = bot.rate_limiter
        
        # Command cooldowns in seconds
        self.cooldowns = {
            'raid': 5,      # Joining a raid
            'invest': 5,    # Additional investment
            'crew': 10,     # Checking raid status
            'stats': 30     # Checking raid stats
        }
        
        # Global cooldowns in seconds
        self.global_cooldowns = {
            'raid': 1,
            'invest': 1,
            'crew': 2,
            'stats': 5
        }

    async def validate_command(
        self,
        command: str,
        user_id: str,
        raid_state: str,
        **kwargs
    ) -> Tuple[bool, Optional[str]]:
        """Validate command execution with rate limiting and state checks"""
        try:
            # Check rate limits first
            can_execute, wait_time = await self.rate_limiter.can_execute(
                command,
                user_id,
                self.cooldowns.get(command, 3),
                self.global_cooldowns.get(command, 1)
            )
            
            if not can_execute:
                return False, f"Please wait {wait_time:.1f} seconds before using this command again."

            # Validate command based on raid state
            state_valid, error_msg = self._validate_state(command, raid_state)
            if not state_valid:
                return False, error_msg

            # Command-specific validation
            if command == 'raid':
                return await self._validate_raid_join(user_id, **kwargs)
            elif command == 'invest':
                return await self._validate_investment(user_id, **kwargs)
            
            return True, None

        except Exception as e:
            logger.error(f"Error validating command {command}: {e}")
            return False, "Error validating command"

    def _validate_state(self, command: str, raid_state: str) -> Tuple[bool, Optional[str]]:
        """Validate command against current raid state"""
        valid_states = {
            'raid': ['RECRUITING', 'MILESTONE'],
            'invest': ['MILESTONE'],
            'crew': ['RECRUITING', 'MILESTONE', 'LAUNCHING', 'ACTIVE'],
            'stats': None  # Can be used in any state
        }

        if command not in valid_states:
            return False, "Invalid command"

        required_states = valid_states[command]
        if required_states is None:
            return True, None

        if raid_state not in required_states:
            state_msg = "No raid is active" if raid_state == "INACTIVE" else f"Cannot use this command in {raid_state.lower()} state"
            return False, state_msg

        return True, None

    async def _validate_raid_join(self, user_id: str, amount: Optional[int] = None, **kwargs) -> Tuple[bool, Optional[str]]:
        """Validate raid join command"""
        try:
            # Validate user isn't already in raid
            if await self._is_user_in_raid(user_id):
                return False, "You are already participating in this raid"

            # Validate investment amount
            if not amount:
                return False, "Please specify an investment amount"

            try:
                amount = int(amount)
            except ValueError:
                return False, "Investment amount must be a number"

            if amount < 100 or amount > 1000:
                return False, "Investment must be between 100 and 1000 points"

            # Check user has enough points
            current_points = await self.bot.points_manager.get_points(user_id)
            if current_points < amount:
                return False, f"Not enough points (You have: {current_points})"

            return True, None

        except Exception as e:
            logger.error(f"Error validating raid join: {e}")
            return False, "Error validating raid join"

    async def _validate_investment(self, user_id: str, amount: Optional[int] = None, **kwargs) -> Tuple[bool, Optional[str]]:
        """Validate additional investment command"""
        try:
            # Validate user is in raid
            if not await self._is_user_in_raid(user_id):
                return False, "You are not participating in this raid"

            # Validate investment amount
            if not amount:
                return False, "Please specify an investment amount"

            try:
                amount = int(amount)
            except ValueError:
                return False, "Investment amount must be a number"

            # Get current investment
            current_investment = await self._get_current_investment(user_id)
            if current_investment + amount > 2000:
                return False, f"Total investment cannot exceed 2000 points"

            # Check user has enough points
            current_points = await self.bot.points_manager.get_points(user_id)
            if current_points < amount:
                return False, f"Not enough points (You have: {current_points})"

            return True, None

        except Exception as e:
            logger.error(f"Error validating investment: {e}")
            return False, "Error validating investment"

    async def _is_user_in_raid(self, user_id: str) -> bool:
        """Check if user is participating in current raid"""
        return user_id in self.bot.raid_manager.current_raid.participants if self.bot.raid_manager.current_raid else False

    async def _get_current_investment(self, user_id: str) -> int:
        """Get user's current raid investment"""
        if not self.bot.raid_manager.current_raid:
            return 0
        participant = self.bot.raid_manager.current_raid.participants.get(user_id)
        return participant.total_investment if participant else 0

    async def reset_command_cooldown(self, command: str, user_id: str):
        """Reset cooldown for a command"""
        await self.rate_limiter.reset_cooldown(command, user_id)

================
File: core/raid_errors.py
================
# core/raid_errors.py

from enum import Enum
from typing import Optional

class RaidError(Exception):
    """Base class for raid-related errors"""
    pass

class RaidStateError(RaidError):
    """Error for invalid state transitions"""
    pass

class InvestmentError(RaidError):
    """Error for invalid investments"""
    pass

class ParticipationError(RaidError):
    """Error for participation-related issues"""
    pass

class ValidationError(RaidError):
    """Error for validation failures"""
    pass

class ErrorCode(Enum):
    # State Errors
    RAID_ALREADY_ACTIVE = "A raid is already in progress"
    RAID_NOT_ACTIVE = "No raid is currently active"
    INVALID_STATE_TRANSITION = "Invalid raid state transition"
    
    # Investment Errors
    INSUFFICIENT_POINTS = "Not enough points for investment"
    INVESTMENT_TOO_LOW = "Investment amount too low"
    INVESTMENT_TOO_HIGH = "Investment amount too high"
    INVESTMENT_WINDOW_CLOSED = "Investment window is closed"
    
    # Participation Errors
    ALREADY_PARTICIPATING = "Already participating in raid"
    NOT_PARTICIPATING = "Not participating in this raid"
    RAID_FULL = "Raid party is full"
    
    # Validation Errors
    INVALID_AMOUNT = "Invalid amount specified"
    INVALID_USER = "Invalid user"
    COOLDOWN_ACTIVE = "Cooldown still active"

class ErrorHandler:
    """Handles raid-related errors and provides appropriate messages"""
    
    @staticmethod
    def get_error_message(error_code: ErrorCode, context: Optional[dict] = None) -> str:
        """Get user-friendly error message"""
        base_message = error_code.value
        
        if context:
            if error_code == ErrorCode.INSUFFICIENT_POINTS:
                return f"{base_message} (You have: {context.get('current_points', 0)} points)"
            elif error_code == ErrorCode.INVESTMENT_TOO_LOW:
                return f"{base_message} (Minimum: {context.get('min_amount', 100)} points)"
            elif error_code == ErrorCode.INVESTMENT_TOO_HIGH:
                return f"{base_message} (Maximum: {context.get('max_amount', 1000)} points)"
            elif error_code == ErrorCode.COOLDOWN_ACTIVE:
                return f"{base_message} ({context.get('time_remaining', 0)} seconds remaining)"
        
        return base_message

    @staticmethod
    def format_error(error: RaidError) -> str:
        """Format error for logging"""
        return f"{error.__class__.__name__}: {str(error)}"

================
File: core/raid_manager.py
================
# core/raid_manager.py

from datetime import datetime, timezone
from enum import Enum
from typing import Dict, List, Optional
import asyncio
import logging
import random
from database.models import RaidHistory, RaidParticipant, PlayerRaidStats
from sqlalchemy import select, text

from core.raid_errors import ErrorHandler, RaidError, ErrorCode, RaidStateError, ValidationError
from core.raid_validation import RaidValidator
from core.raid_recovery import RaidRecoveryManager

logger = logging.getLogger(__name__)

class RaidState(Enum):
    INACTIVE = "INACTIVE"
    RECRUITING = "RECRUITING"
    MILESTONE = "MILESTONE"
    LAUNCHING = "LAUNCHING"
    ACTIVE = "ACTIVE"
    COMPLETED = "COMPLETED"

class RaidManager:
    def __init__(self, bot):
        self.bot = bot
        self.state = RaidState.INACTIVE
        self.current_raid = None
        self.participants = {}
        self._lock = asyncio.Lock()
        self.validator = RaidValidator()
        self.recovery = RaidRecoveryManager(self)
        
        # Initialize raid-specific attributes
        self.raid_ship_type = None
        self.raid_required_crew = None
        self.raid_start_time = None
        self.raid_viewer_count = None
        self.raid_multiplier = None
        self._recruitment_task = None
        
        # Ship types based on viewer count
        self.ship_types = {
            'small': [
                "Merchant Sloop", "Fishing Vessel", "Supply Barge",
                "Coast Guard Cutter", "Pearl Diving Boat"
            ],
            'medium': [
                "Merchant Brig", "Spice Trader", "Wine Transport",
                "Silk Runner", "Colonial Supply Ship"
            ],
            'large': [
                "Trade Galleon", "East India Trader", "Royal Merchant",
                "Treasure Galleon", "Portuguese Carrack"
            ],
            'epic': [
                "Spanish Armada Ship", "Royal Treasury Fleet",
                "Imperial Gold Transport", "Sultan's Gift Fleet",
                "Portuguese Spice Armada"
            ]
        }

    async def start_raid(self) -> bool:
        """Initialize a new raid"""
        async with self._lock:
            try:
                logger.info(f"Starting raid - Current state: {self.state}")
                
                # Check current state
                if self.state != RaidState.INACTIVE:
                    logger.warning(f"Cannot start raid - current state is {self.state}")
                    return False

                viewer_count = await self.bot.get_viewer_count()
                logger.info(f"Current viewer count: {viewer_count}")
                
                if viewer_count is None or viewer_count <= 0:
                    logger.error("Viewer count is None or zero, cannot start raid.")
                    return False

                # Initialize raid data
                self.raid_start_time = datetime.now(timezone.utc)
                self.raid_ship_type = await self._select_ship_type(viewer_count)
                self.raid_required_crew = self._calculate_required_crew(viewer_count)
                self.raid_viewer_count = viewer_count
                self.raid_multiplier = 1.5
                
                logger.info(f"Raid initialized - Ship: {self.raid_ship_type}, Required crew: {self.raid_required_crew}")
                
                # Set state to recruiting and clear any old data
                self.state = RaidState.RECRUITING
                self.participants.clear()
                
                # Start recruitment timer
                if self._recruitment_task and not self._recruitment_task.done():
                    self._recruitment_task.cancel()
                    try:
                        await self._recruitment_task
                    except asyncio.CancelledError:
                        pass
                        
                self._recruitment_task = asyncio.create_task(self._recruitment_timer())
                
                # Announce raid start
                await self._announce_raid_start()
                logger.info("Raid started successfully")
                return True

            except Exception as e:
                logger.error(f"Error starting raid: {e}", exc_info=True)
                await self._reset_raid_data()
                return False
            
    async def _reset_raid_data(self):
        """Reset all raid-related data with task cleanup"""
        try:
            async with self._lock:
                logger.info("Starting raid data reset")
                
                # Cancel recruitment timer if it exists
                if self._recruitment_task and not self._recruitment_task.done():
                    logger.info("Cancelling recruitment task")
                    self._recruitment_task.cancel()
                    try:
                        await asyncio.wait_for(self._recruitment_task, timeout=2.0)
                    except (asyncio.CancelledError, asyncio.TimeoutError):
                        logger.warning("Recruitment task cancellation timed out")
                    self._recruitment_task = None

                # Force immediate state reset
                await self._force_reset()
                
                # Verify state
                if self.is_active:
                    logger.error("State verification failed after reset")
                    await self._force_reset()  # Try one more time
                
                logger.info("Raid data reset completed successfully")

        except Exception as e:
            logger.error(f"Error resetting raid data: {e}")
            # Force reset as last resort
            await self._force_reset()

    @property
    def is_active(self) -> bool:
        """Check if raid is currently active"""
        return (
            self.state != RaidState.INACTIVE and 
            self.state != RaidState.COMPLETED
        )

    async def join_raid(self, user_id: str, username: str, investment: int) -> tuple[bool, str]:
        """Handle a player joining the raid with validation"""
        if self.state != RaidState.RECRUITING:
            return False, "No raid is currently active"
        
        if self.raid_ship_type is None:
            return False, "No raid is currently active"

        async with self._lock:
            try:
                # Validate participant
                is_valid, error_code = self.validator.validate_participant(
                    user_id, 
                    self.participants,
                    self.state.name
                )
                
                if not is_valid:
                    return False, str(error_code.value if error_code else "Invalid participant")

                # Validate investment
                current_points = await self.bot.points_manager.get_points(user_id)
                is_valid, error_code = self.validator.validate_investment(
                    investment,
                    current_points
                )
                
                if not is_valid:
                    return False, str(error_code.value if error_code else "Invalid investment")

                # Add participant
                self.participants[user_id] = {
                    'username': username,
                    'initial_investment': investment,
                    'total_investment': investment
                }

                # Update points
                await self.bot.points_manager.remove_points(
                    user_id,
                    investment,
                    "Raid investment"
                )
                
                # Announce new crew member
                await self.bot.raid_messages.announce_crew_joined(
                    username=username,
                    current=len(self.participants),
                    needed=self.raid_required_crew,
                    investment=investment
                )

                await self._check_milestone()
                
                return True, "Successfully joined the raid!"

            except Exception as e:
                logger.error(f"Error joining raid: {e}")
                await self.recovery.handle_error(e)
                return False, "Error joining raid"
            
    async def _select_ship_type(self, viewer_count: int) -> str:
        """Select appropriate ship type based on viewer count"""
        if viewer_count <= 10:
            return random.choice(self.ship_types['small'])
        elif viewer_count <= 30:
            return random.choice(self.ship_types['medium'])
        elif viewer_count <= 100:
            return random.choice(self.ship_types['large'])
        else:
            return random.choice(self.ship_types['epic'])

    def _calculate_required_crew(self, viewer_count: int) -> int:
        """Calculate required participants based on viewer count"""
        if viewer_count < 10:
            return 2
        return max(2, int(viewer_count * 0.1))

    async def _recruitment_timer(self):
        """Handle recruitment phase timing"""
        try:
            # Announce at 60 seconds remaining
            await asyncio.sleep(60)
            if self.state == RaidState.RECRUITING:
                await self._announce_time_remaining(60)

            # Announce at 30 seconds remaining
            await asyncio.sleep(30)
            if self.state == RaidState.RECRUITING:
                await self._announce_time_remaining(30)

            # Final 30 seconds
            await asyncio.sleep(30)
            
            logger.info("Recruitment timer finished - initiating raid end")
            
            # Important: Use _end_raid instead of _complete_raid
            if self.state == RaidState.RECRUITING:
                async with self._lock:
                    await self._handle_raid_completion()

        except asyncio.CancelledError:
            logger.info("Recruitment timer cancelled")
            raise
        except Exception as e:
            logger.error(f"Error in recruitment timer: {e}")
            await self._handle_raid_error()

    async def _handle_raid_completion(self):
        """Handle the raid completion process"""
        try:
            logger.info(f"Handling raid completion. Participants: {len(self.participants)}/{self.raid_required_crew}")
            
            if len(self.participants) >= self.raid_required_crew:
                # Successful raid
                logger.info("Raid successful - distributing rewards")
                
                # Transition states
                self.state = RaidState.LAUNCHING
                await self._announce_raid_launching()
                await asyncio.sleep(2)

                self.state = RaidState.ACTIVE
                total_plunder = await self._distribute_rewards()

                self.state = RaidState.COMPLETED
                await self._announce_raid_success({
                    'total_plunder': total_plunder,
                    'participants': len(self.participants),
                    'multiplier': self.raid_multiplier,
                    'ship_type': self.raid_ship_type
                })
            else:
                # Failed raid
                logger.info("Raid failed - insufficient participants")
                await self._handle_raid_error()

        except Exception as e:
            logger.error(f"Error in raid completion: {e}")
            await self._handle_raid_error()
        finally:
            # Always ensure we reset state
            logger.info("Resetting raid state after completion")
            await self._force_reset()

    async def _end_raid(self):
        """End the raid and handle rewards"""
        async with self._lock:
            try:
                logger.info(f"Ending raid with {len(self.participants)} participants (need {self.raid_required_crew})")
                
                # Cancel the recruitment timer first
                if self._recruitment_task and not self._recruitment_task.done():
                    self._recruitment_task.cancel()
                    try:
                        await asyncio.wait_for(self._recruitment_task, timeout=1.0)
                    except (asyncio.CancelledError, asyncio.TimeoutError):
                        pass
                    self._recruitment_task = None

                # Check if we have enough participants
                if len(self.participants) >= self.raid_required_crew:
                    logger.info("Sufficient participants - completing raid")
                    self.state = RaidState.LAUNCHING
                    await self._announce_raid_launching()
                    await asyncio.sleep(5)

                    # Move to active and distribute rewards
                    self.state = RaidState.ACTIVE
                    total_plunder = await self._distribute_rewards()
                    
                    # Announce success
                    await self._announce_raid_success({
                        'total_plunder': total_plunder,
                        'participants': len(self.participants),
                        'multiplier': self.raid_multiplier,
                        'ship_type': self.raid_ship_type
                    })

                    # Move to completed then inactive
                    self.state = RaidState.COMPLETED
                    await asyncio.sleep(2)
                else:
                    logger.info("Insufficient participants - cancelling raid")
                    await self._handle_raid_error()

            except Exception as e:
                logger.error(f"Error ending raid: {e}")
                await self._handle_raid_error()
            finally:
                # Force a state reset at the end
                logger.info("Forcing final state reset")
                self.state = RaidState.INACTIVE
                await self._force_reset()

    async def _force_reset(self):
        """Force reset all raid state"""
        try:
            logger.info("Performing force reset of raid state")
            
            # Cancel any existing recruitment timer
            if hasattr(self, '_recruitment_task') and self._recruitment_task:
                if not self._recruitment_task.done():
                    self._recruitment_task.cancel()
                self._recruitment_task = None

            # Reset all state variables
            self.state = RaidState.INACTIVE
            self.raid_ship_type = None
            self.raid_required_crew = None
            self.raid_start_time = None
            self.raid_viewer_count = None
            self.raid_multiplier = None
            self.participants.clear()
            
            logger.info("Force reset completed - state is now INACTIVE")
            
        except Exception as e:
            logger.error(f"Error during force reset: {e}")
            # Ensure critical state is reset even on error
            self.state = RaidState.INACTIVE
            self.participants.clear()

    async def _check_milestone(self):
        """Check for and handle raid milestones"""
        try:
            participant_count = len(self.participants)
            viewer_count = self.current_raid['viewer_count']
            
            new_multiplier = self._calculate_multiplier(participant_count, viewer_count)
            
            if new_multiplier > self.current_raid.get('multiplier', 1.5):
                is_valid, error_code = self.validator.validate_state_transition(
                    str(self.state),
                    'MILESTONE'
                )
                
                if is_valid:
                    self.current_raid['multiplier'] = new_multiplier
                    self.state = RaidState.MILESTONE
                    await self._announce_milestone(new_multiplier)
                    asyncio.create_task(self._milestone_timer())
                else:
                    logger.warning(f"Invalid state transition to milestone: {error_code}")

        except Exception as e:
            logger.error(f"Error checking milestone: {e}")
            await self.recovery.handle_error(e)
    
    async def _milestone_timer(self):
        """Handle milestone investment window"""
        await asyncio.sleep(30)  # 30 second investment window
        
        async with self._lock:
            if self.state == RaidState.MILESTONE:
                self.state = RaidState.RECRUITING
                await self._announce_recruitment_resumed()

    async def increase_investment(self, user_id: str, additional_amount: int) -> tuple[bool, str]:
        """Handle investment increase with validation"""
        async with self._lock:
            try:
                # Validate increase
                is_valid, error_code = self.validator.validate_investment_increase(
                    user_id,
                    additional_amount,
                    self.participants,
                    str(self.state)
                )
                if not is_valid:
                    return False, ErrorHandler.get_error_message(error_code)

                current_points = await self.bot.points_manager.get_points(user_id)
                is_valid, error_code = self.validator.validate_investment(
                    additional_amount,
                    current_points,
                    self.participants[user_id]['total_investment']
                )
                if not is_valid:
                    return False, ErrorHandler.get_error_message(error_code, {'current_points': current_points})

                # Update investment
                participant = self.participants[user_id]
                participant['total_investment'] += additional_amount

                # Update points
                await self.bot.points_manager.remove_points(
                    user_id,
                    additional_amount,
                    "Raid investment increase"
                )

                await self._announce_investment_increased(
                    participant['username'],
                    additional_amount
                )
                
                return True, f"Investment increased by {additional_amount} points!"

            except Exception as e:
                logger.error(f"Error increasing investment: {e}")
                await self.recovery.handle_error(e)
                return False, "Error increasing investment"

    async def _complete_raid(self):
        """Complete the raid with error handling and reward distribution"""
        try:
            async with self._lock:
                # Log current state for debugging
                logger.info(f"Starting raid completion. Current state: {self.state}")

                # Validate state transition
                is_valid, error_code = self.validator.validate_state_transition(
                    self.state,  # Current state
                    RaidState.LAUNCHING  # Target state
                )
                
                if not is_valid:
                    logger.error(f"Cannot complete raid: Invalid state transition from {self.state} to LAUNCHING")
                    await self._handle_raid_error()
                    return

                # Check if we have enough participants
                if len(self.participants) < self.raid_required_crew:
                    logger.info(f"Not enough participants ({len(self.participants)}/{self.raid_required_crew}). Handling as failed raid.")
                    await self._handle_raid_error()
                    return

                try:
                    # State transition
                    self.state = RaidState.LAUNCHING
                    await self._announce_raid_launching()
                    await asyncio.sleep(5)

                    self.state = RaidState.ACTIVE
                    # Calculate and distribute rewards
                    total_plunder = await self._distribute_rewards()
                    
                    # Announce success
                    await self._announce_raid_success({
                        'total_plunder': total_plunder,
                        'participants': len(self.participants),
                        'multiplier': self.raid_multiplier,
                        'ship_type': self.raid_ship_type
                    })

                    # Move to completed state
                    self.state = RaidState.COMPLETED
                    await asyncio.sleep(5)
                    
                except Exception as e:
                    logger.error(f"Error during raid completion: {e}")
                    await self._handle_raid_error()
                    return

                finally:
                    # Always ensure we reset
                    await self._reset_raid_data()

        except Exception as e:
            logger.error(f"Error in raid completion: {e}")
            await self._handle_raid_error()

    async def _distribute_rewards(self):
        """Handle reward distribution"""
        total_plunder = 0
        participant_rewards = []

        async with self.bot.db.session_scope() as session:
            # Create raid history record
            raid_record = RaidHistory(
                start_time=self.raid_start_time,
                end_time=datetime.now(timezone.utc),
                ship_type=self.raid_ship_type,
                viewer_count=self.raid_viewer_count,
                required_crew=self.raid_required_crew,
                final_crew=len(self.participants),
                final_multiplier=self.raid_multiplier,
                total_plunder=0
            )
            session.add(raid_record)
            await session.flush()

            # Process rewards for each participant
            for user_id, participant in self.participants.items():
                investment = participant['total_investment']
                reward = int(investment * self.raid_multiplier)
                total_plunder += reward
                
                # Record participation and prepare rewards
                participation = RaidParticipant(
                    raid_id=raid_record.id,
                    user_id=user_id,
                    initial_investment=participant['initial_investment'],
                    final_investment=investment,
                    reward=reward
                )
                session.add(participation)
                
                participant_rewards.append({
                    'user_id': user_id,
                    'username': participant['username'],
                    'reward': reward
                })

            # Update total plunder
            raid_record.total_plunder = total_plunder
            await session.commit()

        # Distribute rewards after successful database transaction
        for reward_info in participant_rewards:
            try:
                await self.bot.points_manager.add_points(
                    reward_info['user_id'],
                    reward_info['reward'],
                    f"Raid reward ({self.raid_ship_type})"
                )
            except Exception as e:
                logger.error(f"Error distributing reward to {reward_info['username']}: {e}")

        return total_plunder

    async def _handle_raid_error(self):
        """Handle raid errors and cleanup"""
        try:
            logger.info("Handling raid error and cleaning up")
            
            # Process refunds first
            if self.participants:
                for user_id, participant in self.participants.items():
                    try:
                        await self.bot.points_manager.add_points(
                            user_id,
                            participant['total_investment'],
                            "Raid cancelled - refund"
                        )
                        logger.info(f"Refunded {participant['total_investment']} points to {participant['username']}")
                    except Exception as refund_error:
                        logger.error(f"Error processing refund for {user_id}: {refund_error}")

            # Announce the error
            await self._announce_raid_error()
            
        except Exception as e:
            logger.error(f"Error in raid error handler: {e}")
        finally:
            # Always force reset state
            await self._force_reset()

    def reset_state(self):
        """Explicitly reset all raid state"""
        self.state = RaidState.INACTIVE
        self.current_raid = None
        self.participants.clear()
        logger.info("Raid state explicitly reset")


    def _calculate_multiplier(self, participant_count: int, viewer_count: int) -> float:
        """Calculate reward multiplier based on participation"""
        if viewer_count < 10:
            if participant_count >= 5:
                return 2.0
            elif participant_count >= 3:
                return 1.8
            return 1.5
        else:
            participation_rate = participant_count / viewer_count
            if participation_rate >= 0.5:
                return 2.5
            elif participation_rate >= 0.4:
                return 2.2
            elif participation_rate >= 0.3:
                return 2.0
            elif participation_rate >= 0.2:
                return 1.8
            return 1.5

    async def get_raid_status(self) -> Dict:
        """Get current raid status"""
        try:
            logger.info(f"Getting raid status - Current state: {self.state}, Ship type: {self.raid_ship_type}")
            
            # Check if raid is active based on state instead of current_raid object
            if self.state == RaidState.INACTIVE or not self.raid_ship_type:
                logger.info("No active raid found")
                return {'state': RaidState.INACTIVE}
            
            status = {
                'state': self.state,
                'ship_type': self.raid_ship_type,
                'current_crew': len(self.participants),
                'required_crew': self.raid_required_crew,
                'multiplier': self.raid_multiplier,
                'time_remaining': await self._get_time_remaining()
            }
            logger.info(f"Returning raid status: {status}")
            return status
            
        except Exception as e:
            logger.error(f"Error getting raid status: {e}", exc_info=True)
            return {'state': RaidState.INACTIVE}

    async def _get_time_remaining(self) -> int:
        """Get seconds remaining in current phase"""
        if not self.raid_ship_type or self.state == RaidState.INACTIVE:
            return 0
        
        if self.state == RaidState.RECRUITING:
            elapsed = (datetime.now(timezone.utc) - self.raid_start_time).total_seconds()
            return max(0, 120 - int(elapsed))  # 120 seconds recruitment window
        
        if self.state == RaidState.MILESTONE:
            return 30  # 30-second milestone window
        
        return 0

    async def _get_time_remaining(self) -> int:
        """Get seconds remaining in current phase"""
        if not self.current_raid or self.state == RaidState.INACTIVE:
            return 0
        
        if self.state == RaidState.RECRUITING:
            elapsed = (datetime.now(timezone.utc) - self.current_raid['start_time']).total_seconds()
            return max(0, 120 - int(elapsed))  # 120 seconds recruitment window
        
        if self.state == RaidState.MILESTONE:
            # Find last milestone time and calculate remaining time in 30-second window
            return 30  # Simplified for now
        
        return 0

    async def get_player_stats(self, user_id: str) -> Dict:
        """Get player's raid statistics"""
        async with self.bot.db.session_scope() as session:
            stats = await session.execute(
                select(PlayerRaidStats).where(PlayerRaidStats.user_id == user_id)
            )
            stats = stats.scalar_one_or_none()
            
            if not stats:
                return {
                    'total_raids': 0,
                    'successful_raids': 0,
                    'total_invested': 0,
                    'total_plunder': 0,
                    'biggest_reward': 0
                }
            
            return {
                'total_raids': stats.total_raids,
                'successful_raids': stats.successful_raids,
                'total_invested': stats.total_invested,
                'total_plunder': stats.total_plunder,
                'biggest_reward': stats.biggest_reward
            }

    async def _announce_raid_start(self):
        """Announce the start of a new raid"""
        try:
            await self.bot.raid_messages.announce_raid_start({
                'ship_type': self.raid_ship_type,
                'required_crew': self.raid_required_crew,
                'viewer_count': self.raid_viewer_count
            })

        except Exception as e:
            logger.error(f"Error announcing raid start: {e}")

    async def _check_milestone(self) -> bool:
        """Check if a new milestone has been reached"""
        try:
            participant_count = len(self.participants)
            
            if not hasattr(self, 'milestones'):
                self._setup_milestones()

            for milestone in self.milestones:
                if (participant_count >= milestone['count'] and 
                    self.raid_multiplier < milestone['multiplier']):
                    self.raid_multiplier = milestone['multiplier']
                    await self._announce_milestone(milestone)
                    return True
            
            return False

        except Exception as e:
            logger.error(f"Error checking milestone: {e}")
            return False
        
    def _setup_milestones(self):
        """Setup raid milestones based on viewer count"""
        if self.raid_viewer_count < 10:
            self.milestones = [
                {'count': 3, 'multiplier': 1.8, 'description': "Crew growing stronger!"},
                {'count': 5, 'multiplier': 2.0, 'description': "Full crew assembled!"}
            ]
        else:
            participant_threshold = max(3, int(self.raid_viewer_count * 0.1))
            self.milestones = [
                {'count': participant_threshold, 'multiplier': 1.8, 
                 'description': "Initial crew assembled!"},
                {'count': int(participant_threshold * 1.5), 'multiplier': 2.0,
                 'description': "Strong crew formed!"},
                {'count': int(participant_threshold * 2), 'multiplier': 2.5,
                 'description': "Legendary crew ready!"}
            ]

    async def _announce_milestone(self, milestone: dict):
        """Announce reaching a new milestone"""
        try:
            await self.bot.raid_messages.announce_milestone(
                description=milestone['description'],
                multiplier=milestone['multiplier']
            )
        except Exception as e:
            logger.error(f"Error announcing milestone: {e}")

    async def _announce_recruitment_resumed(self):
        """Announce recruitment phase resuming after milestone"""
        await self.bot.raid_messages.announce_raid_start({
            'ship_type': self.raid_ship_type,
            'current_crew': len(self.participants),
            'required_crew': self.raid_required_crew
        })

    async def _announce_raid_launching(self) -> None:
        """Announce raid launching"""
        try:
            await self.bot.raid_messages.announce_raid_launching({
                'ship_type': self.raid_ship_type,
                'crew_size': len(self.participants),
                'multiplier': self.raid_multiplier
            })
        except Exception as e:
            logger.error(f"Error announcing raid launch: {e}")

    async def _announce_raid_success(self, data: dict) -> None:
        """Announce successful raid completion"""
        try:
            await self.bot.raid_messages.announce_raid_success(data)
        except Exception as e:
            logger.error(f"Error announcing raid success: {e}")
            # Fallback message
            try:
                await self.bot.send_chat_message(
                    f"Raid successful! Total plunder: {data['total_plunder']} points!"
                )
            except Exception as e2:
                logger.error(f"Error sending fallback success message: {e2}")

    async def _announce_raid_error(self) -> None:
        """Announce raid failure or error"""
        try:
            await self.bot.raid_messages.announce_raid_failure({
                'ship_type': self.raid_ship_type
            })
        except Exception as e:
            logger.error(f"Error announcing raid failure: {e}")
            # Fallback message if the fancy announcement fails
            try:
                await self.bot.send_chat_message("Raid cancelled! All investments have been refunded.")
            except Exception as e2:
                logger.error(f"Error sending fallback message: {e2}")

    async def _announce_time_remaining(self, time_remaining: int) -> None:
        """Announce remaining time in raid"""
        try:
            await self.bot.raid_messages.announce_time_remaining(
                time_remaining,
                {
                    'ship_type': self.raid_ship_type,
                    'current_crew': len(self.participants),
                    'required_crew': self.raid_required_crew
                }
            )
        except Exception as e:
            logger.error(f"Error announcing time remaining: {e}")

    async def _announce_player_joined(self, username: str):
        """Announce when a player joins the raid"""
        await self.bot.raid_messages.announce_crew_joined(
            username=username,
            current=len(self.participants),
            needed=self.raid_required_crew
        )

    async def _announce_investment_increased(self, username: str, amount: int):
        """Announce when a player increases their investment"""
        await self.bot.raid_messages.announce_investment_increase(
            username=username,
            amount=amount
        )

================
File: core/raid_messages.py
================
# core/raid_messages.py

import logging
import random
from typing import Dict, Optional, List
from dataclasses import dataclass
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

@dataclass
class MessageContext:
    ship_type: str
    crew_count: int
    required_crew: int
    multiplier: float
    total_investment: int = 0
    username: Optional[str] = None
    investment: Optional[int] = None
    plunder: Optional[int] = None
    time_remaining: Optional[int] = None

class RaidMessageHandler:
    def __init__(self, bot):
        self.bot = bot
        self._setup_message_templates()

    def _setup_message_templates(self):
        # Raid start messages
        self.raid_start_messages = [
            "🏴‍☠️ Through the spyglass: A {ship_type} flying {nation} colors spotted to the {direction}!",
            "⛵ Sail ho! A loaded {ship_type} has strayed from its escort in the {weather}!",
            "🌊 {weather} Perfect conditions - a {ship_type} lies at anchor, ripe for the taking!",
            "⚓ Opportunity strikes! A {ship_type} has run aground on the reefs!",
            "🗺️ Our scouts report a {ship_type} taking the long way around - easy pickings!"
        ]

        # Crew join messages
        self.crew_join_messages = [
            "🎯 {username} commits {investment} points to the raid! ({current}/{needed} crew)",
            "💰 {username} throws in {investment} points and joins the crew! ({current}/{needed})",
            "⚔️ {username} contributes {investment} points to the cause! ({current}/{needed})"
        ]

        # Milestone messages
        self.milestone_messages = [
            "⭐ The crew's reputation grows! Reward multiplier increased to {multiplier}x! {description}",
            "💎 Hidden cargo spotted aboard! Raid value now {multiplier}x! {description}",
            "🏆 Elite crew assembled! Rewards increased to {multiplier}x! {description}"
        ]

        # Progress messages
        self.progress_messages = [
            "⏳ {time_remaining} seconds remaining! Need {remaining_crew} more crew members!",
            "⌛ The {ship_type} won't wait forever! {time_remaining} seconds left to join!",
            "⏰ Time is running out! {time_remaining} seconds to join the raid!"
        ]

        # Launch messages
        self.launch_messages = [
            "🚀 The raid on the {ship_type} begins! {crew_size} brave souls against destiny!",
            "⚔️ All hands on deck! {crew_size} raiders move to engage the {ship_type}!",
            "🏃 The crew charges forward! {crew_size} raiders ready for glory!"
        ]

        # Success messages
        self.success_messages = [
            "💰 Victory! The {ship_type} yields {plunder} points of plunder! ({multiplier}x multiplier)",
            "🎉 A successful raid! {plunder} points claimed from the {ship_type}! ({multiplier}x multiplier)",
            "🏆 The crew triumphs! {plunder} points seized from the {ship_type}! ({multiplier}x multiplier)"
        ]

        # Investment increase messages
        self.investment_messages = [
            "💫 {username} seizes the moment with {amount} more points!",
            "✨ {username} increases their stake by {amount} points!",
            "🌟 {username} commits another {amount} points to the raid!"
        ]

        # Crew join messages
        self.crew_join_messages = [
            "🎯 {username} commits {investment} points to the raid! ({current}/{needed} crew)",
            "💰 {username} throws in {investment} points and joins the crew! ({current}/{needed})",
            "⚔️ {username} contributes {investment} points to the cause! ({current}/{needed})"
        ]

        # Failure messages
        self.raid_failure_messages = [
            "The {ship_type} slips away into the mist - not enough crew to attempt the raid!",
            "Without a full crew, we can't catch the {ship_type}. Better luck next time!",
            "The {ship_type} escapes - we needed more hands on deck!",
            "Raid cancelled - the {ship_type} was too well defended for our small crew.",
            "Our small crew couldn't manage the {ship_type}. All investments returned!"
        ]

        # Environment flavor
        self.weather_conditions = [
            "calm seas",
            "light fog",
            "gathering dusk",
            "morning mist",
            "cloudy skies"
        ]

        self.directions = [
            "north", "south", "east", "west",
            "northwest", "northeast", "southwest", "southeast"
        ]

        self.nations = [
            "Spanish", "Portuguese", "Dutch", "French",
            "English", "Venetian", "Imperial"
        ]

    async def announce_raid_start(self, raid_data: dict):
        """Announce the start of a new raid"""
        try:
            # Format message with raid_data
            message = random.choice(self.raid_start_messages).format(
                ship_type=raid_data['ship_type'],
                weather=random.choice(self.weather_conditions),
                direction=random.choice(self.directions),
                nation=random.choice(self.nations)
            )
            
            await self.bot.send_chat_message(message)
            
            # Follow up with crew requirements
            crew_message = (
                f"🏴‍☠️ Seeking {raid_data['required_crew']} brave souls! "
                f"Join with !raid <amount> (100-1000 points)"
            )
            await self.bot.send_chat_message(crew_message)

        except Exception as e:
            logger.error(f"Error announcing raid start: {e}")

    async def announce_raid_active(self, crew_count: int, ship_type: str):
        """Announce that raid is now active"""
        message = f"🚀 The raid on the {ship_type} begins! {crew_count} brave souls against destiny!"
        await self.bot.send_chat_message(message)


    async def announce_crew_joined(self, username: str, current: int, needed: int, investment: int = None):
        """Announce when a new crew member joins"""
        try:
            message = random.choice(self.crew_join_messages).format(
                username=username,
                investment=investment,
                current=current,
                needed=needed
            )
            await self.bot.send_chat_message(message)

            # If almost full crew, add urgency
            if current == needed - 1:
                await self.bot.send_chat_message(f"⚠️ One more crew member needed!")

        except Exception as e:
            logger.error(f"Error announcing crew join: {e}")

    async def announce_investment(self, context: MessageContext) -> None:
        """Announce when someone invests in the raid"""
        try:
            message = random.choice(self.investment_messages).format(
                username=username,
                amount=amount
            )
            await self.bot.send_chat_message(message)
            
            # Check and announce milestones
            if context.crew_count == context.required_crew - 1:
                await self.bot.send_message(
                    f"⚠️ One more crew member needed! Don't miss out on {context.multiplier}x rewards!"
                )

        except Exception as e:
            logger.error(f"Error announcing investment: {e}")

    async def announce_milestone(self, context: MessageContext) -> None:
        """Announce reaching a raid milestone"""
        try:
            message = random.choice(self.milestone_messages).format(**context.__dict__)
            await self.bot.send_message(message)
            
            # Announce investment window
            window_message = (
                f"💫 30-second bonus investment window! "
                f"Use !invest <amount> to increase your stake!"
            )
            await self.bot.send_message(window_message)

        except Exception as e:
            logger.error(f"Error announcing milestone: {e}")

    async def announce_progress(self, context: MessageContext) -> None:
        """Announce raid progress and time remaining"""
        try:
            remaining_crew = context.required_crew - context.crew_count
            
            message = random.choice(self.progress_messages).format(
                time_remaining=context.time_remaining,
                remaining_crew=remaining_crew,
                ship_type=context.ship_type
            )
            
            await self.bot.send_message(message)

        except Exception as e:
            logger.error(f"Error announcing progress: {e}")

    async def announce_raid_failure(self, data: dict) -> None:
        """Announce when a raid fails or is cancelled"""
        message = random.choice(self.raid_failure_messages).format(**data)
        await self.bot.send_chat_message(message)

    async def announce_time_remaining(self, time_remaining: int, raid_data: dict) -> None:
        """Announce remaining time in raid"""
        remaining_crew = raid_data['required_crew'] - raid_data['current_crew']
        message = (
            f"⏳ {time_remaining} seconds remaining! {raid_data['current_crew']}/{raid_data['required_crew']} crew members! "
            f"Need {remaining_crew} more to raid the {raid_data['ship_type']}!"
        )
        await self.bot.send_chat_message(message)

    async def announce_launch(self, context: MessageContext) -> None:
        """Announce raid launching"""
        try:
            message = random.choice(self.launch_messages).format(**context.__dict__)
            await self.bot.send_message(message)

        except Exception as e:
            logger.error(f"Error announcing launch: {e}")

    async def announce_success(self, context: MessageContext) -> None:
        """Announce successful raid completion"""
        try:
            message = random.choice(self.success_messages).format(plunder=total_plunder, **data)
            await self.bot.send_chat_message(message)

        except Exception as e:
            logger.error(f"Error announcing success: {e}")

    async def _announce_top_contributors(self, context: MessageContext) -> None:
        """Announce top contributors to the raid"""
        try:
            # Get top 3 contributors
            async with self.bot.db.session_scope() as session:
                result = await session.execute(
                    text("""
                        SELECT username, final_investment
                        FROM raid_participants rp
                        JOIN users u ON rp.user_id = u.twitch_id
                        WHERE raid_id = (
                            SELECT id FROM raid_history
                            WHERE end_time = (
                                SELECT MAX(end_time) FROM raid_history
                            )
                        )
                        ORDER BY final_investment DESC
                        LIMIT 3
                    """)
                )
                contributors = await result.fetchall()
                
                if contributors:
                    message = "🏅 Top Contributors: " + " | ".join(
                        f"{username} ({investment} points)"
                        for username, investment in contributors
                    )
                    await self.bot.send_message(message)

        except Exception as e:
            logger.error(f"Error announcing top contributors: {e}")

    async def announce_status(self, context: MessageContext) -> None:
        """Announce current raid status"""
        try:
            message = (
                f"📊 Raid Status: {context.ship_type} | "
                f"Crew: {context.crew_count}/{context.required_crew} | "
                f"Multiplier: {context.multiplier}x"
            )
            
            if context.time_remaining:
                message += f" | Time remaining: {context.time_remaining}s"
            
            await self.bot.send_message(message)

        except Exception as e:
            logger.error(f"Error announcing status: {e}")

    async def announce_error(self, message: str) -> None:
        """Announce error condition"""
        try:
            error_message = f"⚠️ {message}"
            await self.bot.send_message(error_message)
        except Exception as e:
            logger.error(f"Error announcing error: {e}")

================
File: core/raid_points.py
================
# core/raid_points.py
import logging
import asyncio
from typing import Dict, Optional, Tuple
from datetime import datetime, timezone
from sqlalchemy import text

logger = logging.getLogger(__name__)

class RaidPointsManager:
    def __init__(self, bot):
        self.bot = bot
        self._lock = asyncio.Lock()
        self.min_investment = 100
        self.max_investment = 1000
        self.max_total_investment = 2000

    async def process_investment(self, user_id: str, amount: int) -> Tuple[bool, str]:
        """Process initial raid investment with validation"""
        if not self._validate_investment_amount(amount):
            return False, f"Investment must be between {self.min_investment} and {self.max_investment} points"

        async with self._lock:
            async with self.bot.db.session_scope() as session:
                try:
                    current_points = await self.bot.points_manager.get_points(user_id)
                    if current_points < amount:
                        return False, f"Not enough points (You have: {current_points})"

                    # Remove points
                    success = await self.bot.points_manager.remove_points(
                        user_id, amount, "Raid investment"
                    )

                    if not success:
                        return False, "Failed to process investment"

                    # Simulate successful transaction
                    await session.commit()
                    return True, "Investment processed successfully"

                except Exception as e:
                    logger.error(f"Error processing investment: {e}")

                    # Rollback the transaction
                    await session.rollback()
                    
                    # Attempt refund if points were removed
                    await self.refund_investment(user_id, amount, str(e))
                    return False, f"Error processing investment: {str(e)}"

    async def get_investment_stats(self, user_id: str) -> Dict:
        """Get user's raid investment statistics."""
        try:
            async with self.bot.db.session_scope() as session:
                query = text("""
                    SELECT 
                        COALESCE(SUM(final_investment), 0) as total_invested,
                        COALESCE(SUM(reward), 0) as total_rewards,
                        COUNT(*) as total_raids
                    FROM raid_participants
                    WHERE user_id = :user_id
                """)
                result = await session.execute(query, {'user_id': user_id})
                row = await result.fetchone()  # Await here to fix the issue

                if not row:
                    return {
                        'total_invested': 0,
                        'total_rewards': 0,
                        'total_raids': 0,
                        'roi': 0
                    }

                total_invested, total_rewards, total_raids = row
                roi = ((total_rewards - total_invested) / total_invested) if total_invested > 0 else 0

                return {
                    'total_invested': total_invested,
                    'total_rewards': total_rewards,
                    'total_raids': total_raids,
                    'roi': roi
                }

        except Exception as e:
            logger.error(f"Error fetching investment stats: {e}")
            return {
                'total_invested': 0,
                'total_rewards': 0,
                'total_raids': 0,
                'roi': 0
            }


    def _validate_investment_amount(self, amount: int) -> bool:
        """Validate investment amount"""
        try:
            amount = int(amount)
            return self.min_investment <= amount <= self.max_investment
        except (TypeError, ValueError):
            return False

    async def refund_investment(self, user_id: str, amount: int, reason: str) -> bool:
        """Refund points in case of raid failure or cancellation"""
        try:
            return await self.bot.points_manager.add_points(
                user_id,
                amount,
                f"Raid refund: {reason}"
            )
        except Exception as e:
            logger.error(f"Error processing refund: {e}")
            return False

================
File: core/raid_recovery.py
================
# core/raid_recovery.py

import logging
import asyncio
from datetime import datetime, timezone, timedelta
from typing import Dict, Optional, List
from sqlalchemy import text

from .raid_errors import RaidError, RaidStateError, ErrorCode
from .raid_states import RaidState, RaidInstance

logger = logging.getLogger(__name__)

class RaidRecoveryManager:
    def __init__(self, bot):
        self.bot = bot
        self.recovery_attempts = 0
        self.max_recovery_attempts = 3
        self.recovery_states = {
            RaidState.RECRUITING: self._recover_recruiting,
            RaidState.MILESTONE: self._recover_milestone,
            RaidState.LAUNCHING: self._recover_launching,
            RaidState.ACTIVE: self._recover_active
        }

    async def _handle_unknown_error(self, error: Exception, raid_instance=None) -> bool:
        """Handle unknown errors during raid operations"""
        logger.error(f"An unknown error occurred during raid recovery: {error}")
        try:
            if self.recovery_attempts > self.max_recovery_attempts:
                await self._force_reset("Max recovery attempts exceeded")
                return False

            if raid_instance:
                await self._cancel_raid(raid_instance, f"Unknown error: {str(error)}")
                
            return False

        except Exception as recovery_error:
            logger.error(f"Error handling unknown error: {recovery_error}")
            return False
        
    async def handle_error(self, error: Exception, raid_instance: Optional[RaidInstance] = None) -> bool:
        """Handle raid errors and attempt recovery"""
        try:
            logger.error(f"Raid error occurred: {str(error)}")
            self.recovery_attempts += 1

            if self.recovery_attempts > self.max_recovery_attempts:
                await self._force_reset("Max recovery attempts exceeded")
                return False

            if isinstance(error, RaidStateError):
                return await self._handle_state_error(error, raid_instance)
            elif isinstance(error, RaidError):
                return await self._handle_raid_error(error, raid_instance)
            else:
                return await self._handle_unknown_error(error, raid_instance)

        except Exception as recovery_error:
            logger.error(f"Error during recovery: {str(recovery_error)}")
            await self._force_reset("Recovery error")
            return False

    async def recover_from_crash(self) -> bool:
        """Recover raid state after bot crash/restart"""
        try:
            async with self.bot.db.session_scope() as session:
                # Find any incomplete raids
                result = await session.execute(
                    text("""
                        SELECT id, start_time, ship_type, required_crew
                        FROM raid_history
                        WHERE end_time IS NULL
                        AND start_time > :cutoff
                        ORDER BY start_time DESC
                        LIMIT 1
                    """),
                    {'cutoff': datetime.now(timezone.utc) - timedelta(hours=1)}
                )
                raid = await result.fetchone()

                if not raid:
                    return True  # No recovery needed

                # Get participants for the incomplete raid
                result = await session.execute(
                    text("""
                        SELECT user_id, initial_investment, final_investment
                        FROM raid_participants
                        WHERE raid_id = :raid_id
                    """),
                    {'raid_id': raid[0]}
                )
                participants = await result.fetchall()

                # Process refunds
                for participant in participants:
                    await self.bot.raid_points_manager.refund_investment(
                        participant[0],
                        participant[2],  # final_investment
                        "Raid recovery after crash"
                    )

                # Mark raid as failed
                await session.execute(
                    text("""
                        UPDATE raid_history
                        SET end_time = :now, status = 'failed'
                        WHERE id = :raid_id
                    """),
                    {
                        'now': datetime.now(timezone.utc),
                        'raid_id': raid[0]
                    }
                )

                return True

        except Exception as e:
            logger.error(f"Error during crash recovery: {e}")
            return False

    async def _handle_state_error(self, error: RaidStateError, raid_instance: Optional[RaidInstance]) -> bool:
        """Handle state-related errors"""
        if not raid_instance:
            return False

        try:
            current_state = raid_instance.state
            recovery_handler = self.recovery_states.get(current_state)
            
            if recovery_handler:
                return await recovery_handler(raid_instance)
            
            # If no handler for state, force reset
            await self._force_reset(f"No recovery handler for state {current_state}")
            return False

        except Exception as e:
            logger.error(f"Error in state recovery: {e}")
            return False

    async def _recover_recruiting(self, raid_instance: RaidInstance) -> bool:
        """Recover from error in recruiting state"""
        try:
            if await self._is_raid_expired(raid_instance):
                await self._cancel_raid(raid_instance, "Raid expired during recovery")
                return True

            # Check if we should transition to milestone
            milestone = raid_instance.check_milestone()
            if milestone:
                raid_instance.state = RaidState.MILESTONE
                
            return True

        except Exception as e:
            logger.error(f"Error recovering recruiting state: {e}")
            return False

    async def _recover_milestone(self, raid_instance: RaidInstance) -> bool:
        """Recover from error in milestone state"""
        try:
            if await self._is_raid_expired(raid_instance):
                await self._cancel_raid(raid_instance, "Raid expired during milestone")
                return True

            # Return to recruiting state
            raid_instance.state = RaidState.RECRUITING
            return True

        except Exception as e:
            logger.error(f"Error recovering milestone state: {e}")
            return False

    async def _recover_launching(self, raid_instance: RaidInstance) -> bool:
        """Recover from error during launch"""
        try:
            # Check if rewards were partially distributed
            distributed = await self._check_partial_distribution(raid_instance)
            
            if distributed:
                # Complete the distribution
                await self.bot.raid_rewards_manager.distribute_rewards(raid_instance)
            else:
                # Cancel and refund
                await self._cancel_raid(raid_instance, "Failed during launch")
                
            return True

        except Exception as e:
            logger.error(f"Error recovering launching state: {e}")
            return False

    async def _recover_active(self, raid_instance: RaidInstance) -> bool:
        """Recover from error during active state"""
        try:
            # Verify all rewards were distributed
            if not await self._verify_rewards(raid_instance):
                await self._cancel_raid(raid_instance, "Reward verification failed")
                return False

            raid_instance.state = RaidState.COMPLETED
            return True

        except Exception as e:
            logger.error(f"Error recovering active state: {e}")
            return False

    async def _cancel_raid(self, raid_instance: RaidInstance, reason: str) -> bool:
        """Cancel raid and process refunds"""
        try:
            refunds = {
                user_id: participant.total_investment
                for user_id, participant in raid_instance.participants.items()
            }
            
            success = await self.bot.raid_points_manager.batch_refund(refunds, reason)
            
            if success:
                raid_instance.state = RaidState.INACTIVE
                
            return success

        except Exception as e:
            logger.error(f"Error canceling raid: {e}")
            return False

    async def _force_reset(self, reason: str):
        """Force reset all raid state"""
        try:
            if hasattr(self.bot, 'raid_manager') and self.bot.raid_manager.current_raid:
                await self._cancel_raid(
                    self.bot.raid_manager.current_raid,
                    f"Force reset: {reason}"
                )
            
            if hasattr(self.bot, 'raid_manager'):
                self.bot.raid_manager.current_raid = None
                self.bot.raid_manager.state = 'INACTIVE'
            
            self.recovery_attempts = 0

        except Exception as e:
            logger.error(f"Error during force reset: {e}")

    async def _is_raid_expired(self, raid_instance: RaidInstance) -> bool:
        """Check if raid has exceeded time limit"""
        time_elapsed = (datetime.now(timezone.utc) - raid_instance.start_time).total_seconds()
        return time_elapsed > 300  # 5 minute limit

    async def _check_partial_distribution(self, raid_instance: RaidInstance) -> bool:
        """Check if rewards were partially distributed"""
        try:
            async with self.bot.db.session_scope() as session:
                result = await session.execute(
                    text("""
                        SELECT COUNT(*) FROM raid_participants
                        WHERE raid_id = (
                            SELECT id FROM raid_history
                            WHERE start_time = :start_time
                        )
                    """),
                    {'start_time': raid_instance.start_time}
                )
                count = (await result.first())[0]
                return count > 0

        except Exception as e:
            logger.error(f"Error checking partial distribution: {e}")
            return False

    async def _verify_rewards(self, raid_instance: RaidInstance) -> bool:
        """Verify all rewards were properly distributed"""
        try:
            rewards = raid_instance.get_rewards()
            
            for user_id, expected_reward in rewards.items():
                points_before = await self.bot.points_manager.get_points(user_id)
                participant = raid_instance.participants[user_id]
                
                # Expected points = current + reward - investment
                expected_points = (
                    points_before + 
                    expected_reward - 
                    participant.total_investment
                )
                
                current_points = await self.bot.points_manager.get_points(user_id)
                if current_points != expected_points:
                    return False
                    
            return True

        except Exception as e:
            logger.error(f"Error verifying rewards: {e}")
            return False

================
File: core/raid_rewards.py
================
# core/raid_rewards.py
import logging
import asyncio
from typing import Dict, Optional, Tuple
from datetime import datetime, timezone
from sqlalchemy import text
from core.raid_states import RaidState


logger = logging.getLogger(__name__)

class RaidRewardManager:
    def __init__(self, bot):
        self.bot = bot
        self._lock = asyncio.Lock()

    async def distribute_rewards(self, raid_instance):
        """Distribute rewards to raid participants."""
        # Log the raid state for debugging
        logger.debug(f"Raid state: {raid_instance.state}")

        # Check for valid raid state
        if raid_instance.state != RaidState.ACTIVE:
            logger.warning(f"Cannot distribute rewards. Invalid state: {raid_instance.state}")
            return False, f"Invalid state: {raid_instance.state}. Cannot distribute rewards."

        if not raid_instance.participants:
            logger.warning("No participants in the raid. Rewards cannot be distributed.")
            return False, "No participants in the raid. Rewards cannot be distributed."

        try:
            rewards = raid_instance.get_rewards()
            for user_id, reward in rewards.items():
                await self.bot.points_manager.add_points(
                    user_id,
                    reward,
                    f"Raid reward ({raid_instance.ship_type})"
                )
            return True, "Rewards distributed successfully."
        except Exception as e:
            logger.error(f"Error distributing rewards: {e}")
            return False, f"Error: {str(e)}"
        
    async def _record_raid_history(self, session, raid_instance) -> Optional[int]:
        """Record raid history and return raid_id"""
        try:
            result = await session.execute(
                text("""
                    INSERT INTO raid_history (
                        start_time, end_time, ship_type, viewer_count,
                        required_crew, final_crew, final_multiplier, total_plunder
                    ) VALUES (
                        :start_time, :end_time, :ship_type, :viewer_count,
                        :required_crew, :final_crew, :final_multiplier, :total_plunder
                    ) RETURNING id
                """),
                {
                    'start_time': raid_instance.start_time,
                    'end_time': datetime.now(timezone.utc),
                    'ship_type': raid_instance.ship_type,
                    'viewer_count': len(raid_instance.participants),
                    'required_crew': raid_instance.required_crew,
                    'final_crew': len(raid_instance.participants),
                    'final_multiplier': raid_instance.current_multiplier,
                    'total_plunder': sum(raid_instance.get_rewards().values())
                }
            )
            row = await result.first()
            return row[0] if row else None
            
        except Exception as e:
            logger.error(f"Error recording raid history: {e}")
            return None

    async def _record_participants(self, session, raid_id: int, raid_instance, rewards: Dict[str, int]):
        """Record all participant data"""
        for user_id, participant in raid_instance.participants.items():
            await session.execute(
                text("""
                    INSERT INTO raid_participants (
                        raid_id, user_id, initial_investment,
                        final_investment, reward
                    ) VALUES (
                        :raid_id, :user_id, :initial_investment,
                        :final_investment, :reward
                    )
                """),
                {
                    'raid_id': raid_id,
                    'user_id': user_id,
                    'initial_investment': participant.initial_investment,
                    'final_investment': participant.total_investment,
                    'reward': rewards[user_id]
                }
            )

    async def _update_player_stats(self, session, raid_instance, rewards: Dict[str, int]):
        """Update player raid statistics"""
        for user_id, reward in rewards.items():
            participant = raid_instance.participants[user_id]
            await session.execute(
                text("""
                    INSERT INTO player_raid_stats (
                        user_id, total_raids, successful_raids,
                        total_invested, total_plunder, biggest_reward
                    ) VALUES (
                        :user_id, 1, 1,
                        :investment, :reward, :reward
                    )
                    ON CONFLICT (user_id) DO UPDATE SET
                        total_raids = player_raid_stats.total_raids + 1,
                        successful_raids = player_raid_stats.successful_raids + 1,
                        total_invested = player_raid_stats.total_invested + :investment,
                        total_plunder = player_raid_stats.total_plunder + :reward,
                        biggest_reward = GREATEST(player_raid_stats.biggest_reward, :reward)
                """),
                {
                    'user_id': user_id,
                    'investment': participant.total_investment,
                    'reward': reward
                }
            )

================
File: core/raid_scheduler.py
================
# core/raid_scheduler.py

import asyncio
import random
import logging
from datetime import datetime, timezone, timedelta
from typing import Dict, Optional, List
from dataclasses import dataclass
from sqlalchemy import text

logger = logging.getLogger(__name__)

@dataclass
class ScheduleConfig:
    min_cooldown: int  # minimum seconds between raids
    max_cooldown: int  # maximum seconds between raids
    min_viewers: int   # minimum viewers required
    active_multiplier: float  # increase chance during high activity
    peak_hours: List[int]    # hours considered peak time
    enabled: bool = True

class RaidScheduler:
    def __init__(self, bot):
        self.bot = bot
        self.is_running = False
        self._task: Optional[asyncio.Task] = None
        self.last_raid_end: Optional[datetime] = None
        # Initialize with a time in the past instead of None
        self.last_raid_end = datetime.now(timezone.utc) - timedelta(hours=1)  # Set to 1 hour ago
        
        # Default configuration
        self.config = ScheduleConfig(
            min_cooldown=1800,    # 30 minutes
            max_cooldown=3600,    # 60 minutes
            min_viewers=2,
            active_multiplier=1.5,
            peak_hours=[19, 20, 21, 22]  # 7PM-10PM
        )
        
        # Activity tracking
        self.recent_activity = []
        self.max_activity_samples = 10

    async def start(self):
        """Start the raid scheduling system"""
        if self.is_running:
            return

        self.is_running = True
        self._task = asyncio.create_task(self._schedule_loop())
        logger.info("Raid scheduler started")

    async def stop(self):
        """Stop the raid scheduling system"""
        self.is_running = False
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
        logger.info("Raid scheduler stopped")

    async def _schedule_loop(self):
        """Main scheduling loop"""
        while self.is_running:
            try:
                if not self.config.enabled:
                    await asyncio.sleep(60)
                    continue

                # Check if we should start a raid
                if await self._should_start_raid():
                    await self._trigger_raid()
                
                # Update activity metrics
                await self._update_activity_metrics()
                
                # Wait before next check
                await asyncio.sleep(60)

            except Exception as e:
                logger.error(f"Error in raid scheduler: {e}")
                await asyncio.sleep(60)

    async def _should_start_raid(self) -> bool:
        """Determine if we should start a raid based on current conditions"""
        # Don't start if a raid is already active
        if self.bot.raid_manager.state != 'INACTIVE':
            return False

        # Check cooldown
        if self.last_raid_end:
            elapsed = (datetime.now(timezone.utc) - self.last_raid_end).total_seconds()
            if elapsed < self.config.min_cooldown:
                return False

        # Check viewer count
        viewer_count = await self.bot.get_viewer_count()
        if viewer_count < self.config.min_viewers:
            return False

        # If we're past max cooldown, force a raid
        if self.last_raid_end:
            if elapsed >= self.config.max_cooldown:
                return True

        # Calculate probability based on conditions
        if self.last_raid_end and elapsed >= self.config.min_cooldown:
            base_chance = self._calculate_base_chance()
            current_hour = datetime.now(timezone.utc).hour
            
            # Increase chance during peak hours
            if current_hour in self.config.peak_hours:
                base_chance *= 1.5
            
            # Increase chance with more viewers
            viewer_multiplier = min(viewer_count / 10, 2)
            base_chance *= viewer_multiplier
            
            # Increase chance during high activity
            activity_multiplier = self._get_activity_multiplier()
            base_chance *= activity_multiplier
            
            return random.random() < base_chance

        return False

    def _calculate_base_chance(self) -> float:
        """Calculate base probability for raid start"""
        elapsed = (datetime.now(timezone.utc) - self.last_raid_end).total_seconds()
        progress = (elapsed - self.config.min_cooldown) / (self.config.max_cooldown - self.config.min_cooldown)
        return min(0.1 + (progress * 0.4), 0.5)  # 10% to 50% chance

    async def _update_activity_metrics(self):
        """Update chat activity metrics"""
        try:
            # Get recent message count
            async with self.bot.db.session_scope() as session:
                result = await session.execute(
                    text("""
                        SELECT COUNT(*) FROM message_log
                        WHERE timestamp > :cutoff
                    """),
                    {'cutoff': datetime.now(timezone.utc) - timedelta(minutes=5)}
                )
                message_count = (await result.first())[0]
            
            self.recent_activity.append(message_count)
            if len(self.recent_activity) > self.max_activity_samples:
                self.recent_activity.pop(0)

        except Exception as e:
            logger.error(f"Error updating activity metrics: {e}")

    def _get_activity_multiplier(self) -> float:
        """Calculate activity multiplier based on recent chat activity"""
        if not self.recent_activity:
            return 1.0

        avg_activity = sum(self.recent_activity) / len(self.recent_activity)
        if avg_activity > 50:  # Very active
            return self.config.active_multiplier
        elif avg_activity > 20:  # Moderately active
            return 1.25
        return 1.0

    async def update_config(self, **kwargs) -> bool:
        """Update scheduler configuration"""
        try:
            for key, value in kwargs.items():
                if hasattr(self.config, key):
                    setattr(self.config, key, value)
            logger.info(f"Scheduler config updated: {kwargs}")
            return True
        except Exception as e:
            logger.error(f"Error updating scheduler config: {e}")
            return False

    async def force_raid(self) -> bool:
        """Force start a raid (for mod commands)"""
        try:
            if not self.config.enabled:
                return False
            
            # Set last_raid_end to ensure validation passes
            if self.last_raid_end is None:
                self.last_raid_end = datetime.now(timezone.utc) - timedelta(hours=1)
                
            return await self.bot.raid_manager.start_raid()
        except Exception as e:
            logger.error(f"Error force starting raid: {e}")
            return False

    def update_last_raid(self):
        """Update the last raid end time"""
        self.last_raid_end = datetime.now(timezone.utc)

    async def get_next_raid_estimate(self) -> Dict:
        """Get estimated time until next raid"""
        if not self.config.enabled:
            return {"enabled": False}
            
        if not self.last_raid_end:
            return {"estimate": "Soon"}
            
        elapsed = (datetime.now(timezone.utc) - self.last_raid_end).total_seconds()
        min_remaining = max(0, self.config.min_cooldown - elapsed)
        max_remaining = max(0, self.config.max_cooldown - elapsed)
        
        return {
            "enabled": True,
            "min_time": min_remaining,
            "max_time": max_remaining,
            "peak_hours": self.config.peak_hours,
            "current_probability": self._calculate_base_chance()
        }

================
File: core/raid_states.py
================
# raid_states.py
from enum import Enum, auto
from typing import Dict, Optional, List
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone

class RaidState(Enum):
    INACTIVE = auto()
    RECRUITING = auto()
    MILESTONE = auto()
    LAUNCHING = auto()
    ACTIVE = auto()
    COMPLETED = auto()

@dataclass
class RaidMilestone:
    participant_count: int
    multiplier: float
    description: str

@dataclass
class Participant:
    username: str
    initial_investment: int
    total_investment: int
    join_time: datetime

class RaidInstance:
    def __init__(
        self,
        ship_type: str,
        required_crew: int,
        viewer_count: int,
        base_multiplier: float = 1.5
    ):
        self.start_time = datetime.now(timezone.utc)
        self.ship_type = ship_type
        self.required_crew = required_crew
        self.viewer_count = viewer_count
        self.base_multiplier = base_multiplier
        self.current_multiplier = base_multiplier
        self.participants: Dict[str, Participant] = {}
        self.state = RaidState.RECRUITING
        self.milestones: List[RaidMilestone] = []
        self._setup_milestones()
    
    def _setup_milestones(self):
        """Setup raid milestones based on viewer count"""
        if self.viewer_count < 10:
            self.milestones = [
                RaidMilestone(3, 1.8, "Crew growing stronger!"),
                RaidMilestone(5, 2.0, "Full crew assembled!")
            ]
        else:
            participant_threshold = max(3, int(self.viewer_count * 0.1))
            self.milestones = [
                RaidMilestone(
                    participant_threshold, 
                    1.8, 
                    "Initial crew assembled!"
                ),
                RaidMilestone(
                    int(participant_threshold * 1.5), 
                    2.0, 
                    "Strong crew formed!"
                ),
                RaidMilestone(
                    int(participant_threshold * 2), 
                    2.5, 
                    "Legendary crew ready!"
                )
            ]

    def add_participant(self, user_id: str, username: str, investment: int) -> bool:
        """Add a participant to the raid"""
        if self.state not in [RaidState.RECRUITING, RaidState.MILESTONE]:
            return False
            
        if user_id in self.participants:
            return False
            
        self.participants[user_id] = Participant(
            username=username,
            initial_investment=investment,
            total_investment=investment,
            join_time=datetime.now(timezone.utc)
        )
        
        return True

    def increase_investment(self, user_id: str, additional: int) -> bool:
        """Increase a participant's investment"""
        if self.state != RaidState.MILESTONE:
            return False
            
        if user_id not in self.participants:
            return False
            
        participant = self.participants[user_id]
        if participant.total_investment + additional > 2000:
            return False
            
        participant.total_investment += additional
        return True

    def check_milestone(self) -> Optional[RaidMilestone]:
        """Check if a new milestone has been reached"""
        participant_count = len(self.participants)
        
        for milestone in self.milestones:
            if (participant_count >= milestone.participant_count and 
                milestone.multiplier > self.current_multiplier):
                self.current_multiplier = milestone.multiplier
                return milestone
                
        return None

    def get_status(self) -> Dict:
        """Get current raid status"""
        return {
            'state': self.state,
            'ship_type': self.ship_type,
            'required_crew': self.required_crew,
            'current_crew': len(self.participants),
            'multiplier': self.current_multiplier,
            'total_investment': sum(
                p.total_investment for p in self.participants.values()
            ),
            'time_elapsed': (
                datetime.now(timezone.utc) - self.start_time
            ).total_seconds(),
            'next_milestone': next(
                (m for m in self.milestones 
                 if len(self.participants) < m.participant_count),
                None
            )
        }

    def get_rewards(self) -> Dict[str, int]:
        """Calculate rewards for all participants"""
        return {
            user_id: int(participant.total_investment * self.current_multiplier)
            for user_id, participant in self.participants.items()
        }

    def is_successful(self) -> bool:
        """Check if raid meets success criteria"""
        return len(self.participants) >= self.required_crew

================
File: core/raid_validation.py
================
# core/raid_validation.py

from asyncio.log import logger
from typing import Optional, Tuple, Dict
from datetime import datetime, timezone
from .raid_errors import ErrorCode, ValidationError, RaidStateError

class RaidValidator:
    """Validates raid operations and state transitions"""

    @staticmethod
    def validate_raid_start(current_state: str, last_raid_end: Optional[datetime],
                          viewer_count: int) -> Tuple[bool, Optional[ErrorCode]]:
        """Validate if a raid can be started"""
        # Debug the incoming state
        logger.debug(f"Validating raid start - Current state: {current_state}, Type: {type(current_state)}")
        
        # Convert RaidState enum to string if needed
        if hasattr(current_state, 'name'):
            current_state = current_state.name
            
        # Case-insensitive comparison
        if current_state.upper() != 'INACTIVE':
            logger.debug(f"Raid validation failed - State is {current_state}, expected INACTIVE")
            return False, ErrorCode.RAID_ALREADY_ACTIVE

        if last_raid_end:
            cooldown = 1800  # 30 minutes
            elapsed = (datetime.now(timezone.utc) - last_raid_end).total_seconds()
            if elapsed < cooldown:
                return False, ErrorCode.COOLDOWN_ACTIVE

        if viewer_count < 2:
            return False, ErrorCode.INVALID_STATE_TRANSITION

        return True, None

    @staticmethod
    def validate_investment(amount: int, current_points: int, 
                          existing_investment: Optional[int] = None) -> Tuple[bool, Optional[ErrorCode]]:
        """Validate investment amount"""
        try:
            amount = int(amount)
        except (TypeError, ValueError):
            return False, ErrorCode.INVALID_AMOUNT

        if amount < 100:
            return False, ErrorCode.INVESTMENT_TOO_LOW
            
        if amount > 1000:
            return False, ErrorCode.INVESTMENT_TOO_HIGH

        if existing_investment and (existing_investment + amount) > 2000:
            return False, ErrorCode.INVESTMENT_TOO_HIGH

        if amount > current_points:
            return False, ErrorCode.INSUFFICIENT_POINTS

        return True, None

    @staticmethod
    def validate_participant(user_id: str, participants: dict,
                           state: str) -> Tuple[bool, ErrorCode]:
        """Validate participant actions"""
        if not user_id:
            return False, ErrorCode.INVALID_USER

        if user_id in participants:
            return False, ErrorCode.ALREADY_PARTICIPATING

        if state not in ['RECRUITING', 'MILESTONE']:
            return False, ErrorCode.RAID_NOT_ACTIVE

        return True, None

    @staticmethod
    def validate_state_transition(current_state: str, new_state: str) -> Tuple[bool, Optional[ErrorCode]]:
        """Validate state transitions"""
        # Map of valid state transitions
        valid_transitions = {
            'RECRUITING': ['MILESTONE', 'LAUNCHING', 'INACTIVE'],
            'MILESTONE': ['RECRUITING', 'LAUNCHING'],
            'LAUNCHING': ['ACTIVE', 'INACTIVE'],
            'ACTIVE': ['COMPLETED', 'INACTIVE'],
            'COMPLETED': ['INACTIVE'],
            'INACTIVE': ['RECRUITING']
        }

        # Convert enum to string if needed
        if hasattr(current_state, 'name'):
            current_state = current_state.name
        
        if hasattr(new_state, 'name'):
            new_state = new_state.name

        # Ensure states are uppercase for comparison
        current_state = current_state.upper()
        new_state = new_state.upper()

        logger.info(f"Validating state transition: {current_state} -> {new_state}")

        if current_state not in valid_transitions:
            logger.error(f"Invalid current state: {current_state}")
            return False, ErrorCode.INVALID_STATE_TRANSITION

        if new_state not in valid_transitions[current_state]:
            logger.error(f"Invalid transition from {current_state} to {new_state}")
            return False, ErrorCode.INVALID_STATE_TRANSITION

        return True, None

    @staticmethod
    def validate_investment_increase(user_id: str, amount: int,
                                  participants: Dict, state: str) -> Tuple[bool, Optional[ErrorCode]]:
        """Validate investment increase"""
        if state != 'MILESTONE':
            return False, ErrorCode.INVESTMENT_WINDOW_CLOSED

        if user_id not in participants:
            return False, ErrorCode.NOT_PARTICIPATING

        current_investment = participants[user_id]['total_investment']
        if current_investment + amount > 2000:
            return False, ErrorCode.INVESTMENT_TOO_HIGH

        return True, None

================
File: core/rewards.py
================
from twitchio.ext import commands
import asyncio

class RewardManager:
    def __init__(self, bot):
        self.bot = bot
        self.registered_rewards = {}

    async def handle_redemption(self, ctx, reward_id, user, input_text):
        if reward_id in self.registered_rewards:
            await self.registered_rewards[reward_id](ctx, user, input_text)

    def register_reward(self, reward_id, handler):
        self.registered_rewards[reward_id] = handler

================
File: database/manager.py
================
# database/manager.py
from sqlalchemy import create_engine, Column, Integer, String, Boolean, DateTime, text
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.future import select
from datetime import datetime, timezone
from contextlib import asynccontextmanager
from typing import Optional, Dict, Any
import logging
import asyncio

logger = logging.getLogger(__name__)

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    twitch_id = Column(String, unique=True, nullable=False)
    username = Column(String, nullable=False)
    is_mod = Column(Boolean, default=False)
    is_subscriber = Column(Boolean, default=False)
    first_seen = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    last_seen = Column(DateTime, default=lambda: datetime.now(timezone.utc))

class StreamStats(Base):
    __tablename__ = 'stream_stats'
    id = Column(Integer, primary_key=True)
    peak_viewers = Column(Integer, default=0)
    messages_sent = Column(Integer, default=0)

class StreamStatsManager:
    def __init__(self, session_maker):
        self.session_maker = session_maker
        self.viewer_count = 0
        self.messages = 0
        self.current_stats = None

    async def flush(self):
        async with self.session_maker() as session:
            stmt = select(StreamStats).order_by(StreamStats.id.desc()).limit(1)
            result = await session.execute(stmt)
            stats = result.scalar_one_or_none()
            
            if not stats:
                stats = StreamStats(peak_viewers=self.viewer_count, messages_sent=self.messages)
                session.add(stats)
            else:
                stats.peak_viewers = max(stats.peak_viewers, self.viewer_count)
                stats.messages_sent += self.messages
            
            self.current_stats = stats
            await session.commit()
            self.viewer_count = 0
            self.messages = 0


class DatabaseManager:
    def __init__(self, connection_url: Optional[str] = None, testing: bool = False):
        self.connection_url = connection_url or 'sqlite+aiosqlite:///bot.db'
        self.engine = None
        self.Session = None
        self.testing = testing
        self.stats = {'connections_created': 0, 'connections_used': 0, 'errors': 0}
        self._setup_engine()
        self.stream_stats_manager = StreamStatsManager(self.session_scope)

    def _setup_engine(self) -> None:
        try:
            self.engine = create_async_engine(
                self.connection_url,
                echo=False,
                future=True
            )
            self.Session = sessionmaker(
                bind=self.engine,
                class_=AsyncSession,
                expire_on_commit=False
            )
            logger.info("Database engine initialized successfully")
        except Exception as e:
            logger.error(f"Error setting up database engine: {e}")
            raise

    @asynccontextmanager
    async def session_scope(self):
        """Provide a transactional scope for database operations."""
        session = self.Session()
        try:
            yield session
            await session.commit()
        except Exception as e:
            await session.rollback()
            self.stats['errors'] += 1
            logger.error(f"Database error: {str(e)}")
            raise
        finally:
            await session.close()

    async def check_connection_health(self) -> bool:
        """Check database connection health"""
        try:
            async with self.session_scope() as session:
                await session.execute(text('SELECT 1'))
            return True
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            self.stats['errors'] += 1
            return False

    async def close(self) -> None:
        """Close database connections"""
        try:
            if self.engine:
                await self.engine.dispose()
            logger.info("Database connections closed successfully")
        except Exception as e:
            logger.error(f"Error closing database connections: {e}")
            raise

    async def get_pool_status(self) -> Dict[str, Any]:
        return {
            'active': bool(self.engine and self.Session),
            'stats': self.stats.copy()
        }
    
    async def get_or_create_user(self, twitch_id: str, username: str) -> User:
        """Fetch or create a user by Twitch ID."""
        async with self.session_scope() as session:
            stmt = select(User).where(User.twitch_id == twitch_id)
            result = await session.execute(stmt)
            user = result.scalar_one_or_none()
            
            if not user:
                user = User(twitch_id=twitch_id, username=username)
                session.add(user)
                await session.commit()
            return user
        
async def initialize_database(db_url: str):
    """Initialize database asynchronously"""
    engine = create_async_engine(db_url)
    async with engine.begin() as conn:
        # Create users table
        await conn.execute(text('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                twitch_id TEXT UNIQUE NOT NULL,
                username TEXT NOT NULL,
                is_mod BOOLEAN DEFAULT FALSE,
                is_subscriber BOOLEAN DEFAULT FALSE,
                is_moderator BOOLEAN DEFAULT FALSE,
                first_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        '''))
        
        # Create raid system tables
        await conn.execute(text('''
            CREATE TABLE IF NOT EXISTS raid_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                start_time TIMESTAMP NOT NULL,
                end_time TIMESTAMP,
                ship_type TEXT NOT NULL,
                viewer_count INTEGER NOT NULL,
                required_crew INTEGER NOT NULL,
                final_crew INTEGER NOT NULL,
                final_multiplier REAL NOT NULL,
                total_plunder INTEGER NOT NULL,
                status TEXT
            )
        '''))

        await conn.execute(text('''
            CREATE TABLE IF NOT EXISTS raid_participants (
                raid_id INTEGER NOT NULL,
                user_id TEXT NOT NULL,
                initial_investment INTEGER NOT NULL,
                final_investment INTEGER NOT NULL,
                reward INTEGER NOT NULL,
                PRIMARY KEY (raid_id, user_id),
                FOREIGN KEY (raid_id) REFERENCES raid_history(id),
                FOREIGN KEY (user_id) REFERENCES users(twitch_id)
            )
        '''))

        await conn.execute(text('''
            CREATE TABLE IF NOT EXISTS player_raid_stats (
                user_id TEXT PRIMARY KEY,
                total_raids INTEGER DEFAULT 0,
                successful_raids INTEGER DEFAULT 0,
                total_invested INTEGER DEFAULT 0,
                total_plunder INTEGER DEFAULT 0,
                biggest_reward INTEGER DEFAULT 0,
                FOREIGN KEY (user_id) REFERENCES users(twitch_id)
            )
        '''))

        # Create other required tables
        await conn.execute(text('''
            CREATE TABLE IF NOT EXISTS banned_phrases (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                phrase TEXT UNIQUE NOT NULL,
                enabled BOOLEAN DEFAULT TRUE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                created_by TEXT
            )
        '''))
        
        await conn.execute(text('''
            CREATE TABLE IF NOT EXISTS stream_stats (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                stream_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                peak_viewers INTEGER DEFAULT 0,
                stream_duration INTEGER DEFAULT 0,
                messages_sent INTEGER DEFAULT 0
            )
        '''))

        await conn.execute(text('''
            CREATE TABLE IF NOT EXISTS user_points (
                user_id TEXT PRIMARY KEY,
                points INTEGER DEFAULT 0,
                total_earned INTEGER DEFAULT 0,
                last_updated TIMESTAMP,
                streak_days INTEGER DEFAULT 0,
                last_daily TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(twitch_id)
            )
        '''))
        
        # Create indexes for better query performance
        await conn.execute(text('CREATE INDEX IF NOT EXISTS idx_raid_history_time ON raid_history(start_time)'))
        await conn.execute(text('CREATE INDEX IF NOT EXISTS idx_raid_participants_user ON raid_participants(user_id)'))
        await conn.execute(text('CREATE INDEX IF NOT EXISTS idx_player_stats_plunder ON player_raid_stats(total_plunder)'))

    await engine.dispose()
    logger.info("Database tables created successfully.")

================
File: database/models.py
================
# database/models.py
from sqlalchemy import Float, create_engine, Column, Integer, String, Boolean, DateTime, ForeignKey, Index, func
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    
    id = Column(Integer, primary_key=True)
    twitch_id = Column(String, unique=True, nullable=False)
    username = Column(String, nullable=False)
    is_mod = Column(Boolean, default=False)
    is_subscriber = Column(Boolean, default=False)
    first_seen = Column(DateTime, default=datetime.utcnow)
    last_seen = Column(DateTime, default=datetime.utcnow)
    
    __table_args__ = (
        Index('idx_users_twitch_id', twitch_id),
        Index('idx_users_status', is_mod, is_subscriber),
        Index('idx_users_activity', last_seen, username),
    )

class CustomCommand(Base):
    __tablename__ = 'custom_commands'
    
    id = Column(Integer, primary_key=True)
    name = Column(String, unique=True, nullable=False)
    response = Column(String, nullable=False)
    permission_level = Column(String, default='everyone')
    enabled = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    __table_args__ = (
        Index('idx_commands_lookup', name, enabled),
        Index('idx_commands_permission', permission_level, enabled),
    )

class StreamStats(Base):
    __tablename__ = 'stream_stats'
    
    id = Column(Integer, primary_key=True)
    stream_date = Column(DateTime, default=datetime.utcnow)
    peak_viewers = Column(Integer, default=0)
    stream_duration = Column(Integer, default=0)
    messages_sent = Column(Integer, default=0)
    
    __table_args__ = (
        Index('idx_stats_date', stream_date),
        Index('idx_stats_metrics', stream_date, peak_viewers, messages_sent),
    )

class BannedPhrase(Base):
    __tablename__ = 'banned_phrases'
    
    id = Column(Integer, primary_key=True)
    phrase = Column(String, nullable=False, unique=True)
    enabled = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    created_by = Column(String)
    
    __table_args__ = (
        Index('idx_banned_phrases_lookup', phrase, enabled),
    )

class Command(Base):
    __tablename__ = 'commands'

    name = Column(String, primary_key=True)
    response = Column(String, nullable=False)

class UserPoints(Base):
    __tablename__ = 'user_points'
    
    user_id = Column(String, primary_key=True)
    points = Column(Integer, default=0)
    total_earned = Column(Integer, default=0)
    last_updated = Column(DateTime, default=datetime.utcnow)
    streak_days = Column(Integer, default=0)
    last_daily = Column(DateTime)

    __table_args__ = (
        Index('idx_points_leaderboard', points.desc()),
    )

class RaidHistory(Base):
    __tablename__ = 'raid_history'
    
    id = Column(Integer, primary_key=True)
    start_time = Column(DateTime, nullable=False, default=datetime.utcnow)
    end_time = Column(DateTime)
    ship_type = Column(String, nullable=False)
    viewer_count = Column(Integer, nullable=False)
    required_crew = Column(Integer, nullable=False)
    final_crew = Column(Integer, nullable=False)
    final_multiplier = Column(Float, nullable=False)
    total_plunder = Column(Integer, nullable=False)
    
    __table_args__ = (
        Index('idx_raid_history_time', 'start_time'),
    )

class RaidParticipant(Base):
    __tablename__ = 'raid_participants'
    
    raid_id = Column(Integer, ForeignKey('raid_history.id'), primary_key=True)
    user_id = Column(String, ForeignKey('users.twitch_id'), primary_key=True)
    initial_investment = Column(Integer, nullable=False)
    final_investment = Column(Integer, nullable=False)
    reward = Column(Integer, nullable=False)
    
    __table_args__ = (
        Index('idx_raid_participants_user', 'user_id'),
    )

class PlayerRaidStats(Base):
    __tablename__ = 'player_raid_stats'
    
    user_id = Column(String, ForeignKey('users.twitch_id'), primary_key=True)
    total_raids = Column(Integer, default=0)
    successful_raids = Column(Integer, default=0)
    total_invested = Column(Integer, default=0)
    total_plunder = Column(Integer, default=0)
    biggest_reward = Column(Integer, default=0)
    
    __table_args__ = (
        Index('idx_player_stats_plunder', 'total_plunder', postgresql_using='btree'),
    )

================
File: features/analytics/tracker.py
================
# features/analytics/tracker.py
import logging
import asyncio
from collections import Counter, deque
from datetime import datetime, timedelta, timezone
from typing import Dict, List, Optional
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class ViewerMetrics:
    timestamp: datetime
    viewer_count: int
    chatters: set
    messages: int = 0

class AnalyticsTracker:
    def __init__(self, bot, max_command_history=720, max_reward_history=720, cleanup_interval=60):
        self.bot = bot
        self.max_command_history = max_command_history
        self.max_reward_history = max_reward_history
        self.viewer_snapshots: deque = deque(maxlen=max_command_history)
        self.command_history = deque(maxlen=max_command_history)
        self.command_usage = Counter()
        self.reward_history = deque(maxlen=max_reward_history)
        self.reward_usage = Counter()
        self.hourly_stats = {}
        self.cleanup_interval = cleanup_interval
        self._lock = asyncio.Lock()
        self.active_chatters: Dict[str, int] = {}
        self.hourly_peaks: Dict[str, int] = {}
        self.last_snapshot = None

    async def log_command(self, command: str):
        """Log a command to analytics."""
        async with self._lock:
            current_time = datetime.now(timezone.utc)
            hour_key = current_time.strftime('%Y-%m-%d-%H')
            if hour_key not in self.hourly_stats:
                self.hourly_stats[hour_key] = Counter()
            self.hourly_stats[hour_key][f"commands_{command}"] += 1
            self.command_history.append((current_time, command))
            self.command_usage[command] += 1

    async def log_reward(self, reward: str):
        """Log a reward redemption to analytics."""
        async with self._lock:
            current_time = datetime.now(timezone.utc)
            hour_key = current_time.strftime('%Y-%m-%d-%H')
            if hour_key not in self.hourly_stats:
                self.hourly_stats[hour_key] = Counter()
            self.hourly_stats[hour_key][f"rewards_{reward}"] += 1
            self.reward_history.append((current_time, reward))
            self.reward_usage[reward] += 1

    async def get_stream_summary(self) -> Dict:
        """Get current stream summary"""
        if not self.bot.stream_start_time:
            return None

        current_time = datetime.now(timezone.utc)
        duration = current_time - self.bot.stream_start_time
        hours, remainder = divmod(int(duration.total_seconds()), 3600)
        minutes, _ = divmod(remainder, 60)
        duration_str = f"{hours}h {minutes}m"

        # Get current stats
        stats = await self.bot.user_tracker.get_session_stats()
        
        return {
            'duration': duration_str,
            'peak_viewers': max(v.viewer_count for v in self.viewer_snapshots) if self.viewer_snapshots else 0,
            'total_messages': stats['total_messages'],
            'unique_chatters': stats['active_users'],
            'top_commands': self.command_usage.most_common(5),
            'top_rewards': self.reward_usage.most_common(5)
        }

    async def get_stats(self, hours: Optional[int] = None) -> Dict:
        """Get analytics statistics, optionally filtering by time window."""
        async with self._lock:
            if hours:
                cutoff = datetime.now(timezone.utc) - timedelta(hours=hours)
                filtered_commands = [
                    command for timestamp, command in self.command_history if timestamp > cutoff
                ]
                filtered_rewards = [
                    reward for timestamp, reward in self.reward_history if timestamp > cutoff
                ]
                commands_usage = Counter(filtered_commands)
                rewards_usage = Counter(filtered_rewards)
            else:
                commands_usage = self.command_usage
                rewards_usage = self.reward_usage

            return {
                "commands": {
                    "total": sum(commands_usage.values()),
                    "unique": len(commands_usage),
                    "most_used": commands_usage.most_common(),
                },
                "rewards": {
                    "total": sum(rewards_usage.values()),
                    "unique": len(rewards_usage),
                    "most_used": rewards_usage.most_common(),
                }
            }

    async def update_session_stats(self, stats: Dict):
        """Update current session statistics"""
        async with self._lock:
            hour_key = datetime.now(timezone.utc).strftime('%Y-%m-%d-%H')
            if hour_key not in self.hourly_stats:
                self.hourly_stats[hour_key] = Counter()
            
            self.hourly_stats[hour_key].update({
                'messages': stats.get('total_messages', 0),
                'chatters': stats.get('active_users', 0),
                'first_time': stats.get('first_time_chatters', 0),
                'returning': stats.get('returning_users', 0)
            })

    async def take_viewer_snapshot(self, viewer_count: int):
        """Take a snapshot of current viewer count and active users"""
        async with self._lock:
            current_time = datetime.now(timezone.utc)
            
            # Create new snapshot
            snapshot = ViewerMetrics(
                timestamp=current_time,
                viewer_count=viewer_count,
                chatters=set(self.active_chatters.keys())
            )
            
            self.viewer_snapshots.append(snapshot)
            
            # Update hourly peaks
            hour_key = current_time.strftime('%Y-%m-%d-%H')
            current_peak = self.hourly_peaks.get(hour_key, 0)
            if viewer_count > current_peak:
                self.hourly_peaks[hour_key] = viewer_count
                
            self.last_snapshot = snapshot
            await self._cleanup_old_data()

    async def track_message(self, user_id: str, username: str):
        """Track chat message for user activity"""
        async with self._lock:
            self.active_chatters[user_id] = self.active_chatters.get(user_id, 0) + 1
            
            if self.last_snapshot:
                self.last_snapshot.messages += 1

    async def calculate_hourly_stats(self) -> Dict[str, Counter]:
        """Calculate hourly statistics based on viewer snapshots."""
        async with self._lock:
            hourly_stats = {}
            for snapshot in self.viewer_snapshots:
                hour_key = snapshot.timestamp.strftime('%Y-%m-%d-%H')
                if hour_key not in hourly_stats:
                    hourly_stats[hour_key] = Counter()
                hourly_stats[hour_key]['viewers'] += snapshot.viewer_count
                hourly_stats[hour_key]['messages'] += snapshot.messages
            return hourly_stats


    async def get_peak_hours(self, limit: int = 10) -> List[Dict]:
        """Get the most active hours based on hourly stats."""
        async with self._lock:
            # Sort hourly stats by total activity (commands + rewards)
            sorted_hours = sorted(
                self.hourly_stats.items(),
                key=lambda x: sum(x[1].values()),  # Sum of all counters
                reverse=True
            )

            return [
                {
                    "hour": datetime.strptime(hour, '%Y-%m-%d-%H').hour,
                    "total_activity": sum(counter.values())
                }
                for hour, counter in sorted_hours[:limit]
            ]


    async def get_most_active_chatters(self, limit: int = 10) -> List[Dict]:
        """Get most active chatters based on message count"""
        async with self._lock:
            # Sort users by message count
            top_chatters = sorted(
                self.active_chatters.items(),
                key=lambda x: x[1],
                reverse=True
            )[:limit]
            
            # Get usernames for the top chatters
            result = []
            for user_id, message_count in top_chatters:
                try:
                    username = await self.bot.db.get_username(user_id)
                    result.append({
                        'user_id': user_id,
                        'username': username,
                        'messages': message_count
                    })
                except Exception as e:
                    logger.error(f"Error getting username for {user_id}: {e}")

            return result

    async def get_activity_analysis(self) -> Dict:
        """Get comprehensive activity analysis"""
        async with self._lock:
            current_time = datetime.now(timezone.utc)
            
            # Analyze recent snapshots
            recent_snapshots = [
                s for s in self.viewer_snapshots
                if (current_time - s.timestamp).total_seconds() <= 3600  # Last hour
            ]
            
            if not recent_snapshots:
                return {
                    'status': 'No recent data available',
                    'viewer_trend': 'stable',
                    'chat_activity': 'low'
                }

            # Calculate viewer trend
            viewer_counts = [s.viewer_count for s in recent_snapshots]
            current_avg = sum(viewer_counts[-10:]) / 10 if len(viewer_counts) >= 10 else 0
            previous_avg = sum(viewer_counts[-20:-10]) / 10 if len(viewer_counts) >= 20 else 0
            
            trend = 'stable'
            if current_avg > previous_avg * 1.1:  # 10% increase
                trend = 'increasing'
            elif current_avg < previous_avg * 0.9:  # 10% decrease
                trend = 'decreasing'

            # Calculate chat activity level
            messages_per_minute = sum(s.messages for s in recent_snapshots) / len(recent_snapshots)
            activity_level = 'low'
            if messages_per_minute > 30:
                activity_level = 'high'
            elif messages_per_minute > 10:
                activity_level = 'medium'

            return {
                'viewer_count': {
                    'current': viewer_counts[-1],
                    'average': round(sum(viewer_counts) / len(viewer_counts), 1),
                    'peak': max(viewer_counts),
                    'trend': trend
                },
                'chat_activity': {
                    'level': activity_level,
                    'messages_per_minute': round(messages_per_minute, 1),
                    'active_chatters': len(self.active_chatters)
                },
                'timestamp': current_time.isoformat()
            }

    async def _cleanup_if_needed(self):
        """Clean up old command history if necessary."""
        async with self._lock:
            # Define a cutoff for old data (e.g., 24 hours)
            current_time = datetime.now(timezone.utc)
            cutoff = current_time - timedelta(hours=24)

            # Filter out old commands
            self.command_history = deque(
                (timestamp, command) for timestamp, command in self.command_history if timestamp > cutoff
            )

    async def _cleanup_old_data(self):
        """Clean up old analytics data."""
        current_time = datetime.now(timezone.utc)  # Use timezone-aware current time
        cutoff = current_time - timedelta(days=7)  # Clean data older than 7 days

        # Clean up hourly stats
        self.hourly_stats = {
            key: value
            for key, value in self.hourly_stats.items()
            if datetime.strptime(key, '%Y-%m-%d-%H').replace(tzinfo=timezone.utc) > cutoff
        }

================
File: features/commands/analytics.py
================
# features/commands/analytics.py
from twitchio.ext import commands
from datetime import datetime, timedelta, timezone
from utils.decorators import rate_limited
import logging

logger = logging.getLogger(__name__)

class AnalyticsCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='stats')
    @rate_limited(cooldown=30)
    async def show_stats(self, ctx):
        """Show current stream statistics"""
        try:
            if not self.bot.stream_start_time:
                await ctx.send("Stream is not live!")
                return

            # Calculate stream duration
            duration = datetime.now(timezone.utc) - self.bot.stream_start_time
            hours, remainder = divmod(int(duration.total_seconds()), 3600)
            minutes, _ = divmod(remainder, 60)
            duration_str = f"{hours}h {minutes}m"

            # Get stream stats
            session_stats = await self.bot.user_tracker.get_session_stats()
            
            await ctx.send(
                f"Stream Stats 📊 Duration: {duration_str} | "
                f"Messages: {session_stats['total_messages']} | "
                f"Unique chatters: {session_stats['active_users']} | "
                f"First-time chatters: {session_stats['first_time_chatters']}"
            )

        except Exception as e:
            logger.error(f"Error showing stats: {e}")
            await ctx.send("Error retrieving stream statistics!")

    @commands.command(name='topcommands')
    @rate_limited(cooldown=30)
    async def show_top_commands(self, ctx):
        """Show most used commands"""
        if not ctx.author.is_mod:
            return
            
        try:
            stats = await self.bot.analytics.get_stream_summary()
            if not stats or not stats['top_commands']:
                await ctx.send("No command statistics available!")
                return
                
            top_cmds = " | ".join(
                f"!{cmd}: {count}" 
                for cmd, count in stats['top_commands']
            )
            await ctx.send(f"Most Used Commands 📈 {top_cmds}")
        except Exception as e:
            logger.error(f"Error showing top commands: {e}")
            await ctx.send("Error retrieving command statistics!")

    @commands.command(name='toprewards')
    @rate_limited(cooldown=30)
    async def show_top_rewards(self, ctx):
        """Show most redeemed channel point rewards"""
        if not ctx.author.is_mod:
            return
            
        try:
            stats = await self.bot.analytics.get_stream_summary()
            if not stats or not stats['top_rewards']:
                await ctx.send("No reward statistics available!")
                return
                
            top_rewards = " | ".join(
                f"{reward}: {count}" 
                for reward, count in stats['top_rewards']
            )
            await ctx.send(f"Most Used Rewards 🎁 {top_rewards}")
        except Exception as e:
            logger.error(f"Error showing top rewards: {e}")
            await ctx.send("Error retrieving reward statistics!")

    @commands.command(name='weeklystats')
    @rate_limited(cooldown=60)
    async def show_weekly_stats(self, ctx):
        """Show statistics for the past 7 days"""
        if not ctx.author.is_mod:
            return
            
        try:
            stats = await self.bot.analytics.get_historical_stats(days=7)
            hours = round(stats['avg_duration'] / 3600, 1)
            
            await ctx.send(
                f"Weekly Stats 📅 Streams: {stats['streams']} | "
                f"Avg. viewers: {round(stats['avg_viewers'])} | "
                f"Avg. duration: {hours}h | "
                f"Total messages: {stats['total_messages']}"
            )
        except Exception as e:
            logger.error(f"Error showing weekly stats: {e}")
            await ctx.send("Error retrieving weekly statistics!")

    @commands.command(name='chatters')
    @rate_limited(cooldown=30)
    async def show_chatter_stats(self, ctx):
        """Show current stream chatter statistics"""
        if not ctx.author.is_mod:
            return
            
        try:
            stats = await self.bot.analytics.get_stream_summary()
            if not stats:
                await ctx.send("No stream statistics available!")
                return
                
            messages_per_chatter = round(
                stats['total_messages'] / stats['unique_chatters']
                if stats['unique_chatters'] > 0 else 0,
                1
            )
            
            await ctx.send(
                f"Chat Stats 💬 Unique chatters: {stats['unique_chatters']} | "
                f"Messages per chatter: {messages_per_chatter} | "
                f"Total messages: {stats['total_messages']}"
            )
        except Exception as e:
            logger.error(f"Error showing chatter stats: {e}")
            await ctx.send("Error retrieving chat statistics!")

    @commands.command(name='streamtime')
    @rate_limited(cooldown=15)
    async def show_stream_time(self, ctx):
        """Show current stream duration and stats"""
        try:
            stats = await self.bot.analytics.get_stream_summary()
            if not stats:
                await ctx.send("Stream is not live!")
                return
                
            await ctx.send(
                f"Stream Time ⏱️ {stats['duration']} | "
                f"Current viewers: {stats['peak_viewers']} | "
                f"Total messages: {stats['total_messages']}"
            )
        except Exception as e:
            logger.error(f"Error showing stream time: {e}")
            await ctx.send("Error retrieving stream time!")

    @commands.command(name='analyze')
    @rate_limited(cooldown=60)
    async def analyze_stats(self, ctx, timeframe: str = "day"):
        """Analyze stats for a specific timeframe (day/week/month)"""
        if not ctx.author.is_mod:
            return
            
        try:
            days = {
                "day": 1,
                "week": 7,
                "month": 30
            }.get(timeframe.lower(), 7)
            
            stats = await self.bot.analytics.get_historical_stats(days=days)
            if not stats['streams']:
                await ctx.send(f"No statistics available for the past {timeframe}!")
                return
                
            await ctx.send(
                f"{timeframe.capitalize()} Analysis 📊 "
                f"Streams: {stats['streams']} | "
                f"Avg. viewers: {round(stats['avg_viewers'])} | "
                f"Avg. duration: {round(stats['avg_duration']/3600, 1)}h | "
                f"Messages: {stats['total_messages']}"
            )
        except Exception as e:
            logger.error(f"Error analyzing stats: {e}")
            await ctx.send("Error analyzing statistics!")

================
File: features/commands/base.py
================
"""Module providing base commands."""
# features/commands/base.py

from datetime import datetime, timezone
from twitchio.ext import commands
from utils.decorators import rate_limited

class BaseCommands(commands.Cog):
    """Class responsible for base commands."""

    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='uptime')
    @rate_limited(cooldown=10)
    async def uptime(self, ctx):
        """Show stream uptime"""
        if not self.bot.stream_start_time:
            await ctx.send("Stream is not live!")
            return

        duration = datetime.now(timezone.utc) - self.bot.stream_start_time
        hours, remainder = divmod(int(duration.total_seconds()), 3600)
        minutes, seconds = divmod(remainder, 60)
        await ctx.send(f"Stream has been live for {hours}h {minutes}m {seconds}s")

    @commands.command(name='commands')
    @rate_limited(cooldown=5)
    async def show_commands(self, ctx):
        """Show available commands"""
        command_names = [command.name for command in self.bot.commands.values()]
        await ctx.send(f"Available commands: {', !'.join(sorted(command_names))}")


    @commands.command(name='ping')
    async def ping(self, ctx):
        """Simple ping command to check if bot is responsive"""
        await ctx.send("Pong! 🏓 Bot is running.")

================
File: features/commands/mod_commands.py
================
# features/commands/mod_commands.py
import logging
from typing import Optional
from twitchio.ext import commands
from utils.decorators import error_boundary

logger = logging.getLogger(__name__)

class ModCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='timeout', aliases=['to'])
    async def timeout_user(self, ctx, username: Optional[str] = None, duration: int = 300, *, reason: str = "No reason provided"):
        """Timeout a user from chat"""
        if not ctx.author.is_mod:
            return
            
        if not username:
            await ctx.send("Usage: !timeout <username> [duration] [reason]")
            return
            
        try:
            await ctx.channel.timeout(username, duration, reason)
            await ctx.send(f"User {username} has been timed out for {duration} seconds. Reason: {reason}")
        except Exception as e:
            logger.error(f"Failed to timeout user: {e}")
            await ctx.send(f"Failed to timeout user {username}")

    @commands.command(name='ban')
    async def ban_user(self, ctx, username: Optional[str] = None, *, reason: str = "No reason provided"):
        """Ban a user from chat"""
        if not ctx.author.is_mod:
            return
            
        if not username:
            await ctx.send("Usage: !ban <username> [reason]")
            return
            
        try:
            await ctx.channel.ban(username, reason)
            await ctx.send(f"User {username} has been banned. Reason: {reason}")
        except Exception as e:
            logger.error(f"Failed to ban user: {e}")
            await ctx.send(f"Failed to ban user {username}")

    @commands.command(name='unban')
    async def unban_user(self, ctx, username: Optional[str] = None):
        """Unban a user from chat"""
        if not ctx.author.is_mod:
            return
            
        if not username:
            await ctx.send("Usage: !unban <username>")
            return
            
        try:
            await ctx.channel.unban(username)
            await ctx.send(f"User {username} has been unbanned")
        except Exception as e:
            logger.error(f"Failed to unban user: {e}")
            await ctx.send(f"Failed to unban user {username}")

    @commands.command(name='clear')
    async def clear_chat(self, ctx):
        """Clear all messages from chat"""
        if not ctx.author.is_mod:
            return
            
        try:
            await ctx.channel.clear()
            await ctx.send("Chat has been cleared")
        except Exception as e:
            logger.error(f"Failed to clear chat: {e}")
            await ctx.send("Failed to clear chat")

    @commands.command(name='followers', aliases=['followersonly'])
    async def followers_only(self, ctx, duration: Optional[int] = None):
        """Enable/disable followers-only mode"""
        if not ctx.author.is_mod:
            return
            
        try:
            if duration is None:
                await ctx.channel.followers_only(False)
                await ctx.send("Followers-only mode disabled")
            else:
                await ctx.channel.followers_only(duration=duration)
                await ctx.send(f"Followers-only mode enabled ({duration} seconds)")
        except Exception as e:
            logger.error(f"Failed to change followers-only mode: {e}")
            await ctx.send("Failed to change followers-only mode")

    @commands.command(name='slow', aliases=['slowmode'])
    async def slow_mode(self, ctx, duration: Optional[int] = None):
        """Enable/disable slow mode"""
        if not ctx.author.is_mod:
            return
            
        try:
            if duration is None:
                await ctx.channel.slow(False)
                await ctx.send("Slow mode disabled")
            else:
                await ctx.channel.slow(duration)
                await ctx.send(f"Slow mode enabled ({duration} seconds)")
        except Exception as e:
            logger.error(f"Failed to change slow mode: {e}")
            await ctx.send("Failed to change slow mode")

    @commands.command(name='subscribers', aliases=['subscribersonly', 'subonly'])
    async def subscribers_only(self, ctx):
        """Toggle subscribers-only mode"""
        if not ctx.author.is_mod:
            return
            
        try:
            # Toggle the mode
            current_mode = getattr(ctx.channel, '_subscribers', False)
            if current_mode:
                await ctx.channel.subscribers_only(False)
                await ctx.send("Subscribers-only mode disabled")
            else:
                await ctx.channel.subscribers_only(True)
                await ctx.send("Subscribers-only mode enabled")
        except Exception as e:
            logger.error(f"Failed to toggle subscribers-only mode: {e}")
            await ctx.send("Failed to change subscribers-only mode")

    @commands.command(name='emoteonly')
    async def emote_only(self, ctx):
        """Toggle emote-only mode"""
        if not ctx.author.is_mod:
            return
            
        try:
            current_mode = getattr(ctx.channel, '_emote_only', False)
            if current_mode:
                await ctx.channel.emote_only(False)
                await ctx.send("Emote-only mode disabled")
            else:
                await ctx.channel.emote_only(True)
                await ctx.send("Emote-only mode enabled")
        except Exception as e:
            logger.error(f"Failed to toggle emote-only mode: {e}")
            await ctx.send("Failed to change emote-only mode")

================
File: features/commands/raid_commands.py
================
"""Module responsible for raid commands."""
# features/commands/raid_commands.py
import logging
import asyncio
from datetime import timezone, datetime, timedelta
from twitchio.ext import commands
from core.raid_manager import RaidState
from utils.decorators import rate_limited

logger = logging.getLogger(__name__)

class RaidCommands(commands.Cog):
    """Class hosting all raid related commands."""
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='raid')
    @rate_limited(cooldown=5)
    async def raid_command(self, ctx, amount: str = None):
        """Join the current raid with an investment"""
        try:
            if not amount or not amount.isdigit():
                await ctx.send(f"@{ctx.author.name} Usage: !raid <amount> (100-1000 points)")
                return

            amount = int(amount)
            if amount < 100 or amount > 1000:
                await ctx.send(f"@{ctx.author.name} Investment must be between 100 and 1000 points!")
                return

            current_points = await self.bot.points_manager.get_points(str(ctx.author.id))
            if amount > current_points:
                await ctx.send(f"@{ctx.author.name} Not enough points! (You have: {current_points})")
                return

            success, message = await self.bot.raid_manager.join_raid(
                str(ctx.author.id),
                ctx.author.name,
                amount
            )

            if success:
                # Points are handled by the raid manager on success
                await ctx.send(f"@{ctx.author.name} {message}")
            else:
                await ctx.send(f"@{ctx.author.name} {message}")

        except Exception as e:
            logger.error(f"Error processing raid command: {e}")
            await ctx.send(f"@{ctx.author.name} Error joining raid!")

    @commands.command(name='invest')
    @rate_limited(cooldown=5)
    async def invest_command(self, ctx, amount: str = None):
        """Increase investment during raid milestone"""
        try:
            if not amount or not amount.isdigit():
                await ctx.send(f"@{ctx.author.name} Usage: !invest <amount>")
                return

            amount = int(amount)
            current_points = await self.bot.points_manager.get_points(str(ctx.author.id))
            if amount > current_points:
                await ctx.send(f"@{ctx.author.name} Not enough points! (You have: {current_points})")
                return

            success, message = await self.bot.raid_manager.increase_investment(
                str(ctx.author.id),
                amount
            )

            await ctx.send(f"@{ctx.author.name} {message}")

        except Exception as e:
            logger.error(f"Error processing invest command: {e}")
            await ctx.send(f"@{ctx.author.name} Error increasing investment!")

    @commands.command(name='crew')
    @rate_limited(cooldown=10)
    async def raid_status(self, ctx):
        """Check current raid status"""
        try:
            status = await self.bot.raid_manager.get_raid_status()
            
            # Check if no raid is active
            if status['state'] == RaidState.INACTIVE:
                await ctx.send("No raid is currently active!")
                return

            message = (
                f"Current Raid: {status['ship_type']} | "
                f"Crew: {status['current_crew']}/{status['required_crew']} | "
                f"Multiplier: {status['multiplier']}x"
            )
            
            if status['time_remaining'] > 0:
                message += f" | Time remaining: {status['time_remaining']}s"

            await ctx.send(message)

        except Exception as e:
            logger.error(f"Error in crew command: {e}", exc_info=True)
            await ctx.send("No raid is currently active!")  # Friendlier error message

    # Moderator commands
    @commands.command(name='forcereset')
    async def force_reset_command(self, ctx):
        """Force reset raid state (Mod only)"""
        if not ctx.author.is_mod:
            return

        try:
            logger.info("Force reset command initiated")
            
            # Try force reset with timeout
            try:
                await asyncio.wait_for(
                    self.bot.raid_manager._reset_raid_data(),
                    timeout=5.0
                )
                
                # Force immediate state reset if needed
                if self.bot.raid_manager.is_active:
                    await self.bot.raid_manager._force_reset()
                
                # Reset scheduler cooldown
                self.bot.raid_scheduler.last_raid_end = datetime.now(timezone.utc) - timedelta(hours=1)
                
                await ctx.send("Raid state has been forcefully reset.")
                logger.info("Force reset completed successfully")
                
            except asyncio.TimeoutError:
                logger.error("Force reset timed out")
                # Try one last force reset
                await self.bot.raid_manager._force_reset()
                await ctx.send("Reset timed out, but state has been force cleared.")
                
        except Exception as e:
            logger.error(f"Error in force reset: {e}")
            # Last resort reset
            try:
                await self.bot.raid_manager._force_reset()
                await ctx.send("Error occurred, but state has been force cleared.")
            except Exception:
                await ctx.send("Critical error resetting raid state!")

    @commands.command(name='forceraid')
    async def force_raid_command(self, ctx, viewers: str = "10"):
        """Force start a raid (Mod only)"""
        if not ctx.author.is_mod:
            return

        try:
            # Debug current state
            logger.debug(f"Force raid - Current state before start: {self.bot.raid_manager.state}")
            
            # Make sure system is cleaned up first
            await self.bot.raid_manager._reset_raid_data()
            
            # Convert viewer count parameter
            try:
                viewer_count = int(viewers)
                if viewer_count < 2:
                    viewer_count = 2
            except ValueError:
                viewer_count = 10
            
            # Create mock function for viewer count
            async def mock_viewer_count():
                return viewer_count
            
            # Store original and replace with mock
            original_get_viewers = self.bot.get_viewer_count
            self.bot.get_viewer_count = mock_viewer_count
            
            try:
                # Force reset scheduler cooldown
                self.bot.raid_scheduler.last_raid_end = datetime.now(timezone.utc) - timedelta(hours=1)
                
                # Start new raid
                success = await self.bot.raid_manager.start_raid()
                if success:
                    await ctx.send(f"Raid started successfully! (Test mode: {viewer_count} viewers)")
                else:
                    logger.debug(f"Force raid - State after failed start: {self.bot.raid_manager.state}")
                    await ctx.send("Couldn't start raid. One might already be active.")
            finally:
                self.bot.get_viewer_count = original_get_viewers
                
        except Exception as e:
            logger.error(f"Error forcing raid: {e}")
            await ctx.send("Error starting raid!")

    @commands.command(name='raidstate')
    async def raid_state_command(self, ctx):
        """Check current raid state (Mod only)"""
        if not ctx.author.is_mod:
            return
            
        try:
            state = self.bot.raid_manager.state
            is_active = self.bot.raid_manager.is_active
            participants = len(self.bot.raid_manager.participants)
            ship_type = self.bot.raid_manager.raid_ship_type
            
            status_msg = [
                f"Current raid state: {state}",
                f"Raid active: {is_active}",
                f"Participants: {participants}"
            ]
            
            if ship_type:
                status_msg.append(f"Ship Type: {ship_type}")
                
            await ctx.send(" | ".join(status_msg))
            
        except Exception as e:
            logger.error(f"Error getting raid state: {e}")
            await ctx.send("Error retrieving raid state!")

    @commands.command(name='raidstats')
    @rate_limited(cooldown=30)
    async def raid_stats_command(self, ctx):
        """View your raid statistics"""
        try:
            stats = await self.bot.raid_manager.get_player_stats(str(ctx.author.id))
            
            message = (
                f"@{ctx.author.name} Raid Stats | "
                f"Raids: {stats['total_raids']} | "
                f"Successful: {stats['successful_raids']} | "
                f"Total Plunder: {stats['total_plunder']} | "
                f"Biggest Haul: {stats['biggest_reward']}"
            )
            
            await ctx.send(message)

        except Exception as e:
            logger.error(f"Error processing raid stats command: {e}")
            await ctx.send(f"@{ctx.author.name} Error getting raid stats!")

================
File: features/commands/rewards.py
================
class RewardCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.setup_rewards()

    def setup_rewards(self):
        # Register reward handlers
        self.bot.reward_handler.register_reward(
            'reward_id_here',
            self.handle_timeout_reward
        )

    async def handle_timeout_reward(self, user, input):
        target = input.strip().lower()
        if target and not self.bot.get_user(target).is_mod:
            await self.bot.timeout(target, 60, "Channel point reward redemption")

================
File: features/moderation/moderator.py
================
# features/moderation/moderator.py
from sqlalchemy import text
import logging
from typing import Dict, List, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class TimeoutInfo:
    user_id: str
    moderator: str
    reason: str
    duration: int
    timestamp: datetime

class ModerationManager:
    def __init__(self, bot):
        self.bot = bot
        self.timeout_history: Dict[str, List[TimeoutInfo]] = {}
        self.banned_phrases: List[str] = []
        self.user_warnings: Dict[str, int] = {}
        self.caps_threshold = 0.7
        self.spam_threshold = 3
        self.message_history: Dict[str, List[str]] = {}

    async def load_banned_phrases(self):
        """Load banned phrases from database"""
        try:
            async with self.bot.db.session_scope() as session:
                result = await session.execute(
                    text("SELECT phrase FROM banned_phrases WHERE enabled = TRUE")
                )
                # Use the result's scalars() method instead of fetchall()
                self.banned_phrases = [row[0] for row in result.all()]
                logger.info(f"Loaded {len(self.banned_phrases)} banned phrases")
        except Exception as e:
            logger.error(f"Error loading banned phrases: {e}")
            # Set empty list as fallback
            self.banned_phrases = []

    async def add_banned_phrase(self, phrase: str, moderator: str):
        """Add a new banned phrase"""
        try:
            async with self.bot.db.session_scope() as session:
                await session.execute(
                    text("""
                        INSERT INTO banned_phrases (phrase, enabled, created_by) 
                        VALUES (:phrase, TRUE, :moderator)
                    """),
                    {'phrase': phrase.lower(), 'moderator': moderator}
                )
                await session.commit()
                await self.load_banned_phrases()
                logger.info(f"Added banned phrase: {phrase} by {moderator}")
                return True
        except Exception as e:
            logger.error(f"Error adding banned phrase: {e}")
            return False

    async def remove_banned_phrase(self, phrase: str):
        """Remove a banned phrase"""
        try:
            async with self.bot.db.session_scope() as session:
                await session.execute(
                    text("UPDATE banned_phrases SET enabled = FALSE WHERE phrase = :phrase"),
                    {'phrase': phrase.lower()}
                )
                await session.commit()
                await self.load_banned_phrases()
                logger.info(f"Removed banned phrase: {phrase}")
                return True
        except Exception as e:
            logger.error(f"Error removing banned phrase: {e}")
            return False

    async def check_message(self, message) -> Optional[str]:
        """Check message against moderation rules"""
        if not message.content:
            return None
            
        content = message.content.lower()
        user_id = str(message.author.id)

        # Check banned phrases if any exist
        if self.banned_phrases and any(phrase in content for phrase in self.banned_phrases):
            return "banned phrase"

        # Check caps
        if len(message.content) > 10:
            caps_ratio = sum(1 for c in message.content if c.isupper()) / len(message.content)
            if caps_ratio > self.caps_threshold:
                return "excessive caps"

        # Check spam
        if user_id not in self.message_history:
            self.message_history[user_id] = []
        
        self.message_history[user_id].append(content)
        if len(self.message_history[user_id]) > self.spam_threshold:
            self.message_history[user_id].pop(0)
            
        if len(self.message_history[user_id]) == self.spam_threshold:
            if all(msg == content for msg in self.message_history[user_id]):
                return "spam"

        return None

    async def handle_message_moderation(self, message):
        """Handle message moderation"""
        try:
            if message.author.is_mod:
                return

            violation = await self.check_message(message)
            if violation:
                user_id = str(message.author.id)
                warning_count = await self.warn_user(user_id)
                
                # Escalating timeout durations
                duration = 300 * warning_count  # 5 minutes * warning count
                
                await message.delete()
                await self.timeout_user(
                    user_id,
                    "Bot",
                    duration,
                    f"AutoMod: {violation} (Warning #{warning_count})"
                )
                
                await message.channel.send(
                    f"@{message.author.name} message deleted for {violation}. "
                    f"Warning #{warning_count}. Timeout: {duration//60} minutes."
                )
        except Exception as e:
            logger.error(f"Error in message moderation: {e}")

================
File: features/moderation/timeout_manager.py
================
# features/moderation/timeout_manager.py
import time
from typing import Optional, Dict
import logging

logger = logging.getLogger(__name__)

class TimeoutManager:
    def __init__(self, cleanup_interval: int = 3600):
        self.timeout_users: Dict[str, float] = {}  # user -> timeout_end_time
        self.cleanup_interval = cleanup_interval
        self.last_cleanup = time.time()

    def add_timeout(self, user: str, duration: int) -> None:
        """Add a user timeout"""
        self.timeout_users[user] = time.time() + duration
        self._cleanup_if_needed()

    def remove_timeout(self, user: str) -> None:
        """Remove a user's timeout"""
        self.timeout_users.pop(user, None)

    def get_remaining_timeout(self, user: str) -> Optional[int]:
        """Get remaining timeout duration in seconds"""
        if user not in self.timeout_users:
            return None
            
        remaining = self.timeout_users[user] - time.time()
        if remaining <= 0:
            self.remove_timeout(user)
            return None
            
        return int(remaining)

    def is_timeout(self, user: str) -> bool:
        """Check if a user is currently timed out"""
        remaining = self.get_remaining_timeout(user)
        return remaining is not None and remaining > 0

    def _cleanup_if_needed(self) -> None:
        """Clean up expired timeouts periodically"""
        current_time = time.time()
        if current_time - self.last_cleanup > self.cleanup_interval:
            expired = [
                user for user, end_time in self.timeout_users.items()
                if end_time <= current_time
            ]
            for user in expired:
                self.timeout_users.pop(user)
            
            if expired:
                logger.debug(f"Cleaned up {len(expired)} expired timeouts")
            self.last_cleanup = current_time

================
File: features/points/commands.py
================
# features/points/commands.py\
import logging
from twitchio.ext import commands
from utils.decorators import rate_limited
from datetime import datetime, timezone
from sqlalchemy import text

logger = logging.getLogger(__name__)

class PointsCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.points_name = "points"  # You can customize this name

    @commands.command(name='points')
    @rate_limited(cooldown=10)
    async def check_points(self, ctx):
        """Check your current points balance"""
        user_id = str(ctx.author.id)

        try:
            async with self.bot.db.session_scope() as session:
                # Attempt to retrieve the user's points
                result = await session.execute(
                    text('SELECT points FROM user_points WHERE user_id = :user_id'),
                    {'user_id': user_id}
                )
                row = result.first()

                # Insert new user if they do not exist in the table
                if row is None:
                    points = 0
                    await session.execute(
                        text('''
                            INSERT INTO user_points (user_id, points, total_earned, last_updated)
                            VALUES (:user_id, :points, :total_earned, :last_updated)
                        '''),
                        {
                            'user_id': user_id,
                            'points': points,
                            'total_earned': points,
                            'last_updated': datetime.now(timezone.utc)
                        }
                    )
                    await session.commit()
                    logger.info(f"New user {ctx.author.name} ({user_id}) added with {points} points.")
                else:
                    points = row[0]
                    logger.info(f"User {ctx.author.name} ({user_id}) has {points} points.")

                # Send the user's points balance
                await ctx.send(f"@{ctx.author.name} You have {points} {self.points_name}!")

        except Exception as e:
            logger.error(f"Error checking points for user {user_id} ({ctx.author.name}): {e}")
            await ctx.send(f"@{ctx.author.name} Error checking points!")



    @commands.command(name='top')
    @rate_limited(cooldown=30)
    async def show_leaderboard(self, ctx):
        """Show points leaderboard"""
        try:
            async with self.bot.db.session_scope() as session:
                result = await session.execute(text('''
                    SELECT up.points, u.username 
                    FROM user_points up
                    JOIN users u ON up.user_id = u.twitch_id
                    ORDER BY up.points DESC LIMIT 5
                '''))
                rows = result.all()
                
                if rows:
                    leaders = [f"#{i+1} {username}: {points}" for i, (points, username) in enumerate(rows)]
                    await ctx.send(f"Top {self.points_name}: {' | '.join(leaders)}")
                else:
                    await ctx.send("No point earners yet!")
        except Exception as e:
            logger.error(f"Error showing leaderboard: {e}")
            await ctx.send("Error fetching leaderboard!")

    @commands.command(name='give')
    @rate_limited(cooldown=10)
    async def give_points(self, ctx, target: str = None, amount: str = None):
        """Give points to another user"""
        if not target or not amount:
            await ctx.send(f"Usage: !give <username> <amount>")
            return
            
        try:
            amount = int(amount)
            if amount <= 0:
                await ctx.send(f"@{ctx.author.name} Amount must be positive!")
                return
                
            # Get target user
            async with self.bot.db.session_scope() as session:
                query = text('SELECT twitch_id FROM users WHERE LOWER(username) = :name')
                result = await session.execute(query, {'name': target.lower()})
                target_id = result.scalar()
                
                if not target_id:
                    await ctx.send(f"@{ctx.author.name} User not found!")
                    return
                
                # Try transferring points
                sender_points = await self.bot.points_manager.get_points(str(ctx.author.id))
                if sender_points >= amount:
                    now = datetime.now(timezone.utc)
                    update_query = text('''
                        UPDATE user_points 
                        SET points = CASE
                            WHEN user_id = :sender_id THEN points - :amount
                            WHEN user_id = :target_id THEN points + :amount
                        END,
                        last_updated = :now
                        WHERE user_id IN (:sender_id, :target_id)
                    ''')
                    await session.execute(update_query, {
                        'sender_id': str(ctx.author.id),
                        'target_id': target_id,
                        'amount': amount,
                        'now': now
                    })
                    await ctx.send(f"@{ctx.author.name} gave {amount} {self.points_name} to @{target}!")
                else:
                    await ctx.send(f"@{ctx.author.name} You don't have enough {self.points_name}!")
                    
        except ValueError:
            await ctx.send(f"@{ctx.author.name} Invalid amount!")
        except Exception as e:
            logger.error(f"Error giving points: {e}")
            await ctx.send(f"@{ctx.author.name} Error giving points!")

    @commands.command(name='setpoints')
    async def set_points(self, ctx, target: str = None, amount: str = None):
        """Set a user's points (mod only)"""
        if not ctx.author.is_mod:
            return
            
        if not target or not amount:
            await ctx.send("Usage: !setpoints <username> <amount>")
            return
            
        try:
            amount = int(amount)
            if amount < 0:
                await ctx.send("Amount cannot be negative!")
                return
                
            async with self.bot.db.session_scope() as session:
                now = datetime.now(timezone.utc)
                query = text('''
                    UPDATE user_points 
                    SET points = :amount,
                        last_updated = :now
                    WHERE user_id = (
                        SELECT twitch_id 
                        FROM users 
                        WHERE LOWER(username) = :username
                    )
                ''')
                await session.execute(query, {
                    'amount': amount,
                    'now': now,
                    'username': target.lower()
                })
                await ctx.send(f"Set @{target}'s {self.points_name} to {amount}!")
                
        except ValueError:
            await ctx.send("Invalid amount!")
        except Exception as e:
            logger.error(f"Error setting points: {e}")
            await ctx.send("Error setting points!")

================
File: features/points/points_manager.py
================
# features/points/points_manager.py
from datetime import datetime, timezone, timedelta
from typing import Dict, Optional, List
import logging
import asyncio

from sqlalchemy import text

logger = logging.getLogger(__name__)

class PointsManager:
    def __init__(self, bot):
        self.bot = bot
        self.points_per_minute = 10
        self.active_multiplier = 2.0
        self.subscriber_multiplier = 1.5
        self._lock = asyncio.Lock()

    async def setup(self):
        """Initialize database tables for points system."""
        async with self.bot.db.session_scope() as session:
            try:
                queries = [
                    text('''
                        CREATE TABLE IF NOT EXISTS user_points (
                            user_id TEXT PRIMARY KEY,
                            points INTEGER DEFAULT 0,
                            total_earned INTEGER DEFAULT 0,
                            last_updated TIMESTAMP,
                            streak_days INTEGER DEFAULT 0,
                            last_daily TIMESTAMP
                        )
                    '''),
                    text('''
                        CREATE TABLE IF NOT EXISTS points_transactions (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            user_id TEXT,
                            amount INTEGER,
                            reason TEXT,
                            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                            FOREIGN KEY (user_id) REFERENCES user_points(user_id)
                        )
                    '''),
                    text('''
                        CREATE TABLE IF NOT EXISTS users (
                            id INTEGER PRIMARY KEY AUTOINCREMENT,
                            twitch_id TEXT UNIQUE,
                            username TEXT,
                            is_mod BOOLEAN DEFAULT FALSE,
                            is_subscriber BOOLEAN DEFAULT FALSE,
                            first_seen TIMESTAMP,
                            last_seen TIMESTAMP
                        )
                    ''')
                ]
                for query in queries:
                    await session.execute(query)
                logger.info("Tables initialized successfully.")
            except Exception as e:
                logger.error(f"Error initializing tables: {e}")
                raise

    async def add_points(self, user_id: str, amount: int, reason: str = None) -> bool:
        """Add points to a user's balance."""
        async with self._lock:
            async with self.bot.db.session_scope() as session:
                try:
                    now = datetime.now(timezone.utc)
                    await session.execute(
                        text("""
                            INSERT INTO user_points (user_id, points, total_earned, last_updated)
                            VALUES (:user_id, :amount, :amount, :now)
                            ON CONFLICT (user_id) DO UPDATE
                            SET points = user_points.points + :amount,
                                total_earned = user_points.total_earned + :amount,
                                last_updated = :now
                        """),
                        {'user_id': user_id, 'amount': amount, 'now': now}
                    )
                    await session.commit()
                    return True
                except Exception as e:
                    logger.error(f"Error adding points: {e}")
                    return False

    async def remove_points(self, user_id: str, amount: int, reason: str = None) -> bool:
        """Remove points from a user's balance."""
        async with self._lock:
            async with self.bot.db.session_scope() as session:
                try:
                    current_points = await self.get_points(user_id)
                    if current_points < amount:
                        return False

                    now = datetime.now(timezone.utc)
                    await session.execute(
                        text("""
                            UPDATE user_points
                            SET points = points - :amount,
                                last_updated = :now
                            WHERE user_id = :user_id
                        """),
                        {'user_id': user_id, 'amount': amount, 'now': now}
                    )
                    await session.commit()
                    return True
                except Exception as e:
                    logger.error(f"Error removing points: {e}")
                    return False

    async def get_points(self, user_id: str) -> int:
        """Get current points balance."""
        try:
            async with self.bot.db.session_scope() as session:
                query = text('SELECT points FROM user_points WHERE user_id = :user_id')
                result = await session.execute(query, {'user_id': user_id})
                points = result.scalar()
                return points if points is not None else 0
        except Exception as e:
            logger.error(f"Error fetching points for user_id {user_id}: {e}")
            return 0

    async def update_watch_time_points(self):
        """Update points for active viewers."""
        try:
            now = datetime.now(timezone.utc)
            inactive_threshold = now - timedelta(minutes=10)
            
            for user_id, activity in self.bot.user_tracker.active_users.items():
                try:
                    # Skip inactive users
                    if activity.last_seen <= inactive_threshold:
                        continue

                    # Calculate points for the user
                    points = self.points_per_minute
                    if activity.is_subscriber:
                        points *= self.subscriber_multiplier
                    if activity.message_count > 0:
                        points *= self.active_multiplier

                    # Round points before adding
                    await self.add_points(user_id, round(points))
                
                except Exception as user_error:
                    logger.error(
                        f"Error updating points for user_id {user_id}: {user_error} | "
                        f"Last Seen: {activity.last_seen}, Message Count: {activity.message_count}"
                    )
        
        except Exception as general_error:
            logger.error(f"Error in update_watch_time_points: {general_error}")

================
File: features/raids/__init__.py
================
# features/raids/__init__.py

import logging
import asyncio
from typing import Optional
from .raid_manager import RaidManager, RaidState
from .message_handler import RaidMessageHandler
from .commands import RaidCommands
from .database import RaidDatabaseManager
from .scheduler import RaidScheduler

logger = logging.getLogger(__name__)

class RaidSystem:
    def __init__(self, bot):
        self.bot = bot
        self.db = None  # RaidDatabaseManager instance
        self.manager = None  # RaidManager instance
        self.messages = None  # RaidMessageHandler instance
        self.scheduler = None  # RaidScheduler instance
        
    async def initialize(self):
        """Initialize the raid system and all its components"""
        try:
            logger.info("Initializing raid system...")
            
            # Initialize components in order of dependency
            self.db = RaidDatabaseManager(self.bot.db)
            await self.db.initialize_tables()
            
            self.messages = RaidMessageHandler()
            self.manager = RaidManager(self.bot)
            self.scheduler = RaidScheduler(
                bot=self.bot,
                raid_manager=self.manager,
                message_handler=self.messages
            )

            # Register commands
            if 'RaidCommands' not in self.bot.cogs:
                self.bot.add_cog(RaidCommands(self.bot))
            
            # Setup event handlers
            self.bot.event_handler.add_handler(
                'channel_points_used',
                self._handle_points_redemption
            )
            
            # Start scheduler
            await self.scheduler.start()
            
            logger.info("Raid system initialized successfully")
            return True

        except Exception as e:
            logger.error(f"Error initializing raid system: {e}")
            return False

    async def cleanup(self):
        """Cleanup raid system on shutdown"""
        try:
            logger.info("Cleaning up raid system...")
            
            if self.scheduler:
                await self.scheduler.stop()
            
            # Handle any active raids
            if self.manager and self.manager.state != RaidState.INACTIVE:
                await self.manager._cleanup_active_raid()
            
            logger.info("Raid system cleanup completed")

        except Exception as e:
            logger.error(f"Error during raid system cleanup: {e}")

    async def _handle_points_redemption(self, user_id: str, reward_id: str):
        """Handle channel point redemptions related to raids"""
        # Future implementation for channel point integration
        pass

    @property
    def active_raid(self) -> Optional[dict]:
        """Get current raid status if active"""
        if self.manager:
            return self.manager.get_raid_status()
        return None

def setup(bot):
    """Setup function for loading the raid system"""
    raid_system = RaidSystem(bot)
    
    # Store reference to raid system in bot
    bot.raid_system = raid_system
    
    # Schedule initialization
    asyncio.create_task(raid_system.initialize())
    
    return raid_system

================
File: features/raids/commands.py
================
from twitchio.ext import commands
from utils.decorators import rate_limited
import logging

logger = logging.getLogger(__name__)

class RaidCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command(name='raid')
    @rate_limited(cooldown=5)
    async def join_raid(self, ctx, amount: str = None):
        """Join the current raid with an investment"""
        try:
            if not amount or not amount.isdigit():
                await ctx.send(f"@{ctx.author.name} Usage: !raid <amount> (100-1000 points)")
                return

            amount = int(amount)
            current_points = await self.bot.points_manager.get_points(str(ctx.author.id))
            
            if amount > current_points:
                await ctx.send(f"@{ctx.author.name} You don't have enough points! (You have: {current_points})")
                return

            success, message = await self.bot.raid_manager.join_raid(
                str(ctx.author.id),
                ctx.author.name,
                amount
            )

            await ctx.send(f"@{ctx.author.name} {message}")

        except Exception as e:
            logger.error(f"Error in raid command: {e}")
            await ctx.send(f"@{ctx.author.name} Error joining raid!")

    @commands.command(name='invest')
    @rate_limited(cooldown=5)
    async def increase_investment(self, ctx, amount: str = None):
        """Increase your investment during milestone windows"""
        try:
            if not amount or not amount.isdigit():
                await ctx.send(f"@{ctx.author.name} Usage: !invest <amount>")
                return

            amount = int(amount)
            current_points = await self.bot.points_manager.get_points(str(ctx.author.id))
            
            if amount > current_points:
                await ctx.send(f"@{ctx.author.name} You don't have enough points! (You have: {current_points})")
                return

            success, message = await self.bot.raid_manager.increase_investment(
                str(ctx.author.id),
                amount
            )

            await ctx.send(f"@{ctx.author.name} {message}")

        except Exception as e:
            logger.error(f"Error in invest command: {e}")
            await ctx.send(f"@{ctx.author.name} Error increasing investment!")

    @commands.command(name='crew')
    @rate_limited(cooldown=10)
    async def raid_status(self, ctx):
        """Check current raid status"""
        try:
            status = await self.bot.raid_manager.get_raid_status()
            
            if status['state'] == 'INACTIVE':
                await ctx.send("No raid currently active!")
                return

            message = (
                f"Current Raid Status: {status['ship_type']} | "
                f"Crew: {status['participant_count']}/{status['required_crew']} | "
                f"Current Multiplier: {status['current_multiplier']}x"
            )

            if status['next_milestone']:
                message += f" | Next milestone: {status['next_milestone'].participant_count} crew"

            await ctx.send(message)

        except Exception as e:
            logger.error(f"Error in crew command: {e}")
            await ctx.send("Error getting raid status!")

    @commands.command(name='bounty')
    @rate_limited(cooldown=30)
    async def raid_stats(self, ctx):
        """View your raid statistics"""
        try:
            stats = await self.bot.raid_manager.get_player_stats(str(ctx.author.id))
            
            message = (
                f"@{ctx.author.name} Raid Stats | "
                f"Total Raids: {stats['total_raids']} | "
                f"Successful: {stats['successful_raids']} | "
                f"Total Plunder: {stats['total_plunder']} points"
            )

            await ctx.send(message)

        except Exception as e:
            logger.error(f"Error in bounty command: {e}")
            await ctx.send(f"@{ctx.author.name} Error getting raid stats!")

================
File: features/raids/message_handler.py
================
# features/raids/message_handler.py

import random
from typing import Dict, Optional
import logging

logger = logging.getLogger(__name__)

class RaidMessageHandler:
    def __init__(self):
        self.raid_start_messages = [
            "Sails on the horizon! {ship_type} spotted bearing {direction}!",
            "Lookout reports a {ship_type} flying {nation} colors!",
            "Through the spyglass: A wealthy {ship_type} has strayed from its escort!",
            "The fog parts to reveal a {ship_type} heavy in the water with cargo!",
            "A {ship_type} has run aground on the reef - easy pickings!",
            "Storm's scattered a convoy - lone {ship_type} at our mercy!"
        ]

        self.crew_join_messages = [
            "{user} throws their lot in with the crew! ({current}/{needed})",
            "{user} signs on for the raid! ({current}/{needed})",
            "{user} takes up arms with the crew! ({current}/{needed})",
            "Yarr! {user} joins the boarding party! ({current}/{needed})",
            "{user} sharpens their cutlass and joins! ({current}/{needed})",
            "{user} checks their powder and joins up! ({current}/{needed})"
        ]

        self.milestone_messages = [
            "By the stars! The {ship_type} is carrying more than we thought!",
            "She's flying the royal flag - this'll be a rich haul!",
            "Look at the size of those cargo holds! Who's up for a bigger share?",
            "That's no ordinary merchant - she's a treasure ship!",
            "The crew spots additional escort ships - but the prize just got bigger!"
        ]

        self.success_messages = [
            "Victory! The {ship_type} strikes her colors!",
            "The cargo's ours! Time to divvy up the spoils!",
            "A clean sweep! Not a single coin left in her holds!",
            "Another successful raid! The crew's reputation grows!",
            "The {ship_type} is ours! Even the captain's parrot surrendered!"
        ]

        self.weather_conditions = [
            "Calm seas and clear skies - perfect raiding weather!",
            "Fog rolling in - we'll catch them unawares!",
            "Storm's brewing, but that's never stopped us before!",
            "High tide's in our favor - full speed ahead!",
            "The moon's hidden by clouds - perfect for a night raid!"
        ]

        self.compass_directions = ["north", "south", "east", "west", "northwest", "northeast", "southwest", "southeast"]
        self.nations = ["Spanish", "Portuguese", "Dutch", "French", "English", "Venetian"]

    def get_raid_start_message(self, ship_type: str) -> str:
        """Generate raid start message"""
        return random.choice(self.raid_start_messages).format(
            ship_type=ship_type,
            direction=random.choice(self.compass_directions),
            nation=random.choice(self.nations)
        )

    def get_crew_join_message(self, username: str, current: int, needed: int) -> str:
        """Generate crew join message"""
        return random.choice(self.crew_join_messages).format(
            user=username,
            current=current,
            needed=needed
        )

    def get_milestone_message(self, ship_type: str, multiplier: float) -> str:
        """Generate milestone message"""
        base_message = random.choice(self.milestone_messages).format(ship_type=ship_type)
        return f"{base_message} (Reward multiplier now {multiplier}x!)"

    def get_success_message(self, ship_type: str, total_crew: int, total_plunder: int) -> str:
        """Generate success message"""
        base_message = random.choice(self.success_messages).format(ship_type=ship_type)
        return f"{base_message} {total_crew} crew members share {total_plunder} points!"

    def get_weather_condition(self) -> str:
        """Get random weather condition"""
        return random.choice(self.weather_conditions)

================
File: features/rewards/base_handler.py
================
# features/rewards/base_handler.py
from abc import ABC, abstractmethod
from typing import Dict, Optional, Callable, Any
import logging
import random
import asyncio
from utils.decorators import error_boundary

logger = logging.getLogger(__name__)

class BaseRewardHandler(ABC):
    def __init__(self, bot):
        self.bot = bot
        self.messages: Dict[str, list[str]] = {}
        self.handlers: Dict[str, Callable] = {}
        self._setup_messages()
        self._setup_handlers()

    @abstractmethod
    def _setup_messages(self) -> None:
        """Set up message templates for this handler"""
        pass

    @abstractmethod
    def _setup_handlers(self) -> None:
        """Set up reward handlers"""
        pass

    async def handle_reward(self, ctx, reward_id: str, user: str, input_text: str) -> None:
        """Main reward handling method with error handling"""
        try:
            handler = self.handlers.get(reward_id)
            if not handler:
                logger.warning(f"No handler found for reward {reward_id}")
                await ctx.send(f"@{user} This reward is not configured.")
                return

            await handler(ctx, user, input_text)

            # Track analytics if available
            if hasattr(self.bot, 'analytics'):
                await self.bot.analytics.log_reward(reward_id)
        except Exception as e:
            logger.error(f"Error handling reward {reward_id}: {str(e)}")
            await self.handle_error(ctx, user, reward_id, e)

    async def handle_error(self, ctx, user: str, reward_id: str, error: Exception) -> None:
        """Handle errors during reward processing"""
        try:
            error_message = f"@{user} Sorry, there was an error processing your reward."
            if isinstance(error, ValueError):
                error_message = f"@{user} {str(error)}"
            await ctx.send(error_message)
        except Exception as e:
            logger.error(f"Error sending error message: {e}")

    async def send_random_message(self, ctx, message_key: str, **kwargs) -> None:
        """Send a random message from the specified template"""
        try:
            messages = self.messages.get(message_key)
            if not messages:
                logger.error(f"Message key '{message_key}' not found")
                await ctx.send("Action completed!")  # Fallback message
                return

            # Only send one message if the key exists
            message = random.choice(messages)
            await ctx.send(message.format(**kwargs))
        except Exception as e:
            logger.error(f"Error sending message: {e}")
            if not messages:  # Only send fallback if no messages were available
                await ctx.send("Action completed!")


    def validate_input(self, input_text: str, min_length: int = 0, max_length: int = 500) -> str:
        """Validate user input"""
        input_text = input_text.strip()
        if not input_text or len(input_text) < min_length:
            raise ValueError("Please provide valid input.")
        if len(input_text) > max_length:
            raise ValueError(f"Input too long (max {max_length} characters).")
        return input_text

================
File: features/rewards/basic_rewards.py
================
import asyncio


class BasicRewards(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.setup_rewards()

    def setup_rewards(self):
        # Custom shoutout
        self.bot.rewards.register_reward(
            'shoutout_reward_id',
            self.handle_shoutout
        )
        
        # VIP status for stream
        self.bot.rewards.register_reward(
            'temp_vip_reward_id',
            self.handle_temp_vip
        )
        
        # Song request
        self.bot.rewards.register_reward(
            'song_request_id',
            self.handle_song_request
        )

    async def handle_shoutout(self, ctx, user, input_text):
        await ctx.send(f"Big shoutout to {user}! {input_text}")
        
    async def handle_temp_vip(self, ctx, user, _):
        await ctx.send(f"/vip {user}")
        await asyncio.sleep(3600)  # 1 hour
        await ctx.send(f"/unvip {user}")
        
    async def handle_song_request(self, ctx, user, song_name):
        await ctx.send(f"Song request from {user}: {song_name} has been added to the queue!")

================
File: features/rewards/handlers.py
================
# features/rewards/handlers.py
from typing import Dict, Optional
import asyncio
import logging
from datetime import datetime, timedelta, timezone
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class RewardStatus(Enum):
    SUCCESS = "success"
    FAILED = "failed"
    PENDING = "pending"
    REFUNDED = "refunded"

@dataclass
class RewardResult:
    status: RewardStatus
    message: str
    cooldown: Optional[int] = None
    metadata: Optional[Dict] = None

class RewardHandlers:
    def __init__(self, bot):
        self.bot = bot
        self.active_rewards: Dict[str, datetime] = {}
        self.handlers = {}  # Initialize as empty
        self.setup_rewards()
        
    def setup_rewards(self):
        """Register all reward handlers with proper validation and error handling"""
        self.handlers = {
            'timeout_reward': self.handle_timeout,
            'highlight_message': self.handle_highlight,
            'emote_only': self.handle_emote_only,
            'channel_vip': self.handle_vip,
            'hydrate': self.handle_hydrate,
            'posture': self.handle_posture,
            'stretch': self.handle_stretch,
            'song_request': self.handle_song_request,
            'custom_shoutout': self.handle_shoutout,
            'follower_only': self.handle_follower_mode,
            'subscriber_only': self.handle_subscriber_mode,
            'custom_alert': self.handle_custom_alert
        }

        # Register rewards with the bot
        for reward_name in self.handlers.keys():
            self.bot.rewards.register_reward(reward_name, self.handlers[reward_name])

    async def handle_highlight(self, user: str, input_text: str) -> RewardResult:
        """Handle highlight message reward"""
        try:
            # Validate the input
            input_text = input_text.strip()
            if not input_text:
                raise ValueError("Message cannot be empty.")
            
            # Simulate sending a highlighted message (replace with actual implementation)
            # Example: Sending to a stream overlay or chat
            await self.bot.overlay_manager.display_highlight(user, input_text)

            return RewardResult(
                status=RewardStatus.SUCCESS,
                message=f"Highlighted message from {user}: {input_text}",
                cooldown=30  # Example cooldown of 30 seconds
            )
        except Exception as e:
            logger.error(f"Error handling highlight message: {e}")
            return RewardResult(
                status=RewardStatus.FAILED,
                message=f"@{user} Failed to process the highlight message."
            )

    async def handle_redemption(self, reward_data: Dict) -> RewardResult:
        """Main reward handling with comprehensive error handling and user feedback"""
        try:
            reward_id = reward_data['reward']['id']
            user = reward_data['user']['login']
            input_text = reward_data.get('user_input', '')
            
            # Check if reward is on cooldown
            if await self._check_cooldown(reward_id):
                remaining_time = int((self.active_rewards[reward_id] - datetime.now(timezone.utc)).total_seconds())
                return RewardResult(
                    status=RewardStatus.FAILED,
                    message=f"@{user} This reward is on cooldown for {remaining_time} seconds!"
                )
            
            handler = self.handlers.get(reward_id)
            if not handler:
                logger.error(f"No handler found for reward ID: {reward_id}")
                return RewardResult(
                    status=RewardStatus.FAILED,
                    message=f"@{user} This reward is not properly configured."
                )
                
            # Execute reward handler
            result = await handler(user, input_text)
            
            # Track analytics
            await self.bot.analytics.log_reward(reward_id, result.status == RewardStatus.SUCCESS)
            
            # Set cooldown if specified
            if result.cooldown:
                await self._set_cooldown(reward_id, result.cooldown)
                
            return result
            
        except Exception as e:
            logger.error(f"Error handling reward redemption: {e}")
            return RewardResult(
                status=RewardStatus.FAILED,
                message=f"@{user} There was an error processing your reward. Please try again later."
            )
        
    async def handle_vip(self, user: str, _input_text: str) -> RewardResult:
        """Handle VIP reward"""
        return RewardResult(
            status=RewardStatus.SUCCESS,
            message=f"@{user} has been granted VIP status!",
            cooldown=300  # Example cooldown of 5 minutes
        )
    
    async def handle_shoutout(self, user: str, _input_text: str) -> RewardResult:
        """Handle shoutout reward"""
        return RewardResult(
            status=RewardStatus.SUCCESS,
            message=f"@{user} has requested a shoutout.",
            cooldown=300  # Example cooldown of 5 minutes
        )
    
    async def handle_song_request(self, user: str, _input_text: str) -> RewardResult:
        """Handle song request reward"""
        return RewardResult(
            status=RewardStatus.SUCCESS,
            message=f"@{user} has requested a song.",
            cooldown=300  # Example cooldown of 5 minutes
        )

    async def handle_hydrate(self, user: str, _input_text: str) -> RewardResult:
        """Handle hydrate reminder"""
        return RewardResult(
            status=RewardStatus.SUCCESS,
            message=f"@{user} reminded everyone to hydrate!",
            cooldown=60  # Example cooldown of 1 minute
        )

    async def handle_posture(self, user: str, _input_text: str) -> RewardResult:
        """Handle posture reminder"""
        return RewardResult(
            status=RewardStatus.SUCCESS,
            message=f"@{user} reminded everyone to check their posture!",
            cooldown=60
        )

    async def handle_stretch(self, user: str, _input_text: str) -> RewardResult:
        """Handle stretch reminder"""
        return RewardResult(
            status=RewardStatus.SUCCESS,
            message=f"@{user} reminded everyone to stretch!",
            cooldown=60
        )

    async def handle_follower_mode(self, user: str, duration: str) -> RewardResult:
        """Handle follower-only mode activation"""
        try:
            # Convert duration to minutes, default to 5 minutes if not specified
            minutes = int(duration) if duration.strip() else 5
            minutes = min(max(1, minutes), 60)  # Limit between 1-60 minutes
            
            channel = self.bot.get_channel(self.bot.channel_name)
            await channel.followers_only(duration=minutes * 60)
            
            return RewardResult(
                status=RewardStatus.SUCCESS,
                message=f"Chat is now in follower-only mode for {minutes} minutes!",
                cooldown=minutes * 60 + 300  # Duration + 5 minute buffer
            )
        except Exception as e:
            logger.error(f"Error setting follower mode: {e}")
            return RewardResult(
                status=RewardStatus.FAILED,
                message=f"@{user} Failed to enable follower-only mode."
            )

    async def handle_subscriber_mode(self, user: str, duration: str) -> RewardResult:
        """Handle subscriber-only mode activation"""
        try:
            minutes = int(duration) if duration.strip() else 5
            minutes = min(max(1, minutes), 60)
            
            channel = self.bot.get_channel(self.bot.channel_name)
            await channel.subscribers_only()
            
            # Schedule mode disable
            asyncio.create_task(self._schedule_mode_disable(
                channel.subscribers_only_off,
                minutes * 60
            ))
            
            return RewardResult(
                status=RewardStatus.SUCCESS,
                message=f"Chat is now in subscriber-only mode for {minutes} minutes!",
                cooldown=minutes * 60 + 300
            )
        except Exception as e:
            logger.error(f"Error setting subscriber mode: {e}")
            return RewardResult(
                status=RewardStatus.FAILED,
                message=f"@{user} Failed to enable subscriber-only mode."
            )

    async def handle_custom_alert(self, user: str, alert_text: str) -> RewardResult:
        """Handle custom on-stream alert"""
        if not alert_text or len(alert_text.strip()) < 1:
            return RewardResult(
                status=RewardStatus.FAILED,
                message=f"@{user} Please provide alert text!"
            )
            
        try:
            # Sanitize alert text
            alert_text = alert_text.strip()[:200]  # Limit length
            
            # Send to overlay system (implementation needed)
            await self.bot.overlay_manager.show_alert(user, alert_text)
            
            return RewardResult(
                status=RewardStatus.SUCCESS,
                message=f"Alert from {user} displayed on stream!",
                cooldown=30,
                metadata={"alert_text": alert_text}
            )
        except Exception as e:
            logger.error(f"Error displaying alert: {e}")
            return RewardResult(
                status=RewardStatus.FAILED,
                message=f"@{user} Failed to display alert. Please try again later."
            )

    async def _schedule_mode_disable(self, disable_func, delay: int):
        """Schedule a chat mode to be disabled after delay"""
        await asyncio.sleep(delay)
        try:
            await disable_func()
        except Exception as e:
            logger.error(f"Error disabling chat mode: {e}")

    async def _check_cooldown(self, reward_id: str) -> bool:
        """Check if a reward is currently on cooldown"""
        if reward_id not in self.active_rewards:
            return False
            
        if datetime.now(timezone.utc) >= self.active_rewards[reward_id]:
            del self.active_rewards[reward_id]
            return False
            
        return True

    async def _set_cooldown(self, reward_id: str, seconds: int):
        """Set a cooldown for a reward"""
        self.active_rewards[reward_id] = datetime.now(timezone.utc) + timedelta(seconds=seconds)

    async def handle_timeout(self, ctx, redeemer: str, target_user: Optional[str]) -> None:
        """Handle timeout reward"""
        if not target_user:
            raise ValueError("You must specify a user to timeout.")
        if target_user in ctx.channel.moderators:
            raise ValueError("Cannot timeout moderators.")
        if target_user in self.active_rewards:
            raise ValueError(f"{target_user} is already timed out.")

        self.active_rewards[target_user] = datetime.now(timezone.utc) + timedelta(minutes=5)
        await ctx.send(f"{target_user} has been timed out for 5 minutes by {redeemer}.")
        await self.bot.analytics.log_reward("timeout_reward", ctx.channel.name, redeemer)


    
    async def handle_emote_only(self, ctx, redeemer: str, _input_text: Optional[str]) -> None:
        """Handle emote-only mode reward"""
        try:
            await ctx.send("/emoteonly")
            await ctx.send("The emote-only mode has been activated!")
            await asyncio.sleep(5)  # Simulate the delay for the mode
            await ctx.send("/emoteonlyoff")
        except Exception as e:
            logger.error(f"Error activating emote-only mode: {e}")
            await ctx.send("Failed to activate emote-only mode.")

================
File: features/rewards/moderation.py
================
# features/rewards/moderation.py
import asyncio
from features.rewards.base_handler import BaseRewardHandler

class ModerationRewardHandler(BaseRewardHandler):
    def _setup_messages(self) -> None:
        self.messages = {
            'timeout': [
                "⏰ {target} has been timed out for 60 seconds (Channel Points Redemption by {user})",
                "⚠️ {target} is taking a 60-second break (Redeemed by {user})"
            ],
            'emote_only': [
                "😄 Chat is now in emote-only mode for 30 seconds!",
                "🎭 Emotes only! Normal chat resumes in 30 seconds!"
            ]
        }

    def _setup_handlers(self) -> None:
        self.handlers = {
            'timeout_reward': self.handle_timeout,
            'emote_only_reward': self.handle_emote_only
        }

    async def handle_timeout(self, ctx, user: str, target: str) -> None:
        if not target:
            await ctx.send("Please specify a user to timeout!")
            return

        target = target.lower().strip()
        if await self.bot.timeout_manager.is_timeout(target):
            await ctx.send(f"@{target} is already timed out!")
            return

        await self.bot.timeout_manager.add_timeout(target, 60)
        await self.send_random_message(ctx, 'timeout', user=user, target=target)
        await self.bot.analytics.log_reward('timeout')

    async def handle_emote_only(self, ctx, user: str, _: str) -> None:
        await ctx.send("/emoteonly")
        await self.send_random_message(ctx, 'emote_only', user=user)
        await asyncio.sleep(30)
        await ctx.send("/emoteonlyoff")
        await self.bot.analytics.log_reward('emote_only')

================
File: features/rewards/rewards.py
================
# features/rewards/rewards.py
from typing import Dict, Optional, Callable, Any
import logging
import asyncio
from datetime import datetime, timezone
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class RewardDefinition:
    id: str
    name: str
    cost: int
    handler: Callable
    cooldown: int = 0
    enabled: bool = True
    user_input_required: bool = False
    mod_bypass: bool = False

class ChannelRewards:
    def __init__(self, bot):
        self.bot = bot
        self.rewards: Dict[str, RewardDefinition] = {}
        self.cooldowns: Dict[str, datetime] = {}
        self.setup_base_rewards()

    def setup_base_rewards(self):
        """Set up default channel point rewards"""
        self.register_reward(
            RewardDefinition(
                id="timeout_user",
                name="Timeout User",
                cost=1000,
                handler=self.handle_timeout,
                cooldown=300,
                user_input_required=True
            )
        )

        self.register_reward(
            RewardDefinition(
                id="highlight_message",
                name="Highlight Message",
                cost=500,
                handler=self.handle_highlight,
                user_input_required=True
            )
        )

        self.register_reward(
            RewardDefinition(
                id="emote_only",
                name="Emote Only Mode",
                cost=2000,
                handler=self.handle_emote_mode,
                cooldown=600
            )
        )

    def register_reward(self, reward: RewardDefinition):
        """Register a new channel point reward"""
        self.rewards[reward.id] = reward
        logger.info(f"Registered reward: {reward.name}")

    async def handle_redemption(self, ctx: Any, reward_id: str, user: str, input_text: Optional[str] = None) -> bool:
        """Handle a reward redemption"""
        try:
            reward = self.rewards.get(reward_id)
            if not reward:
                logger.warning(f"Unknown reward redeemed: {reward_id}")
                return False

            if not reward.enabled:
                await ctx.send(f"@{user} This reward is currently disabled.")
                return False

            if reward.user_input_required and not input_text:
                await ctx.send(f"@{user} This reward requires input text.")
                return False

            # Check cooldown
            if not await self._check_cooldown(reward):
                remaining = await self._get_cooldown_remaining(reward)
                await ctx.send(f"@{user} This reward is on cooldown for {remaining} seconds.")
                return False

            # Execute reward handler
            success = await reward.handler(ctx, user, input_text)
            if success:
                await self._set_cooldown(reward)
                # Track analytics
                await self.bot.analytics.log_reward(reward_id)
                
            return success

        except Exception as e:
            logger.error(f"Error handling reward redemption: {e}")
            await ctx.send(f"@{user} There was an error processing your reward.")
            return False

    # Base reward handlers
    async def handle_timeout(self, ctx: Any, user: str, input_text: str) -> bool:
        """Handle timeout reward"""
        try:
            target = input_text.strip().lower()
            if not target:
                await ctx.send(f"@{user} Please specify a user to timeout!")
                return False

            # Check if target is mod
            channel = self.bot.get_channel(ctx.channel.name)
            if target in channel.moderators:
                await ctx.send(f"@{user} You cannot timeout moderators!")
                return False

            # Execute timeout
            await ctx.channel.timeout(target, 300, f"Channel Points Redemption by {user}")
            await ctx.send(f"@{target} has been timed out for 5 minutes (Redeemed by {user})")
            return True

        except Exception as e:
            logger.error(f"Error in timeout reward: {e}")
            return False

    async def handle_highlight(self, ctx: Any, user: str, input_text: str) -> bool:
        """Handle message highlight reward"""
        try:
            highlighted_message = f"📢 HIGHLIGHTED MESSAGE FROM {user}: {input_text} 📢"
            await ctx.send(highlighted_message)
            return True

        except Exception as e:
            logger.error(f"Error in highlight reward: {e}")
            return False

    async def handle_emote_mode(self, ctx: Any, user: str, _: Optional[str]) -> bool:
        """Handle emote-only mode reward"""
        try:
            await ctx.channel.emote_only()
            await ctx.send(f"Chat is now in emote-only mode for 5 minutes! (Redeemed by {user})")
            
            # Schedule emote-only mode disable
            await asyncio.sleep(300)
            await ctx.channel.emote_only(False)
            await ctx.send("Emote-only mode has been disabled.")
            return True

        except Exception as e:
            logger.error(f"Error in emote-only mode reward: {e}")
            return False

    async def _check_cooldown(self, reward: RewardDefinition) -> bool:
        """Check if a reward is on cooldown"""
        if reward.cooldown == 0:
            return True

        if reward.id not in self.cooldowns:
            return True

        return (datetime.now(timezone.utc) - self.cooldowns[reward.id]).total_seconds() >= reward.cooldown

    async def _set_cooldown(self, reward: RewardDefinition):
        """Set cooldown for a reward"""
        if reward.cooldown > 0:
            self.cooldowns[reward.id] = datetime.now(timezone.utc)

    async def _get_cooldown_remaining(self, reward: RewardDefinition) -> int:
        """Get remaining cooldown time in seconds"""
        if reward.id not in self.cooldowns:
            return 0

        elapsed = (datetime.now(timezone.utc) - self.cooldowns[reward.id]).total_seconds()
        remaining = reward.cooldown - elapsed
        return max(0, int(remaining))

================
File: features/rewards/stream_interaction.py
================
# features/rewards/stream_interaction.py
from features.rewards.base_handler import BaseRewardHandler

class StreamInteractionHandler(BaseRewardHandler):
    def _setup_messages(self) -> None:
        self.messages = {
            'hydrate': [
                "🚰 Time to hydrate! Take a sip of water!",
                "💧 Hydration check! Drink up!",
                "🌊 Stay hydrated! Water break!"
            ],
            'posture': [
                "🪑 Posture check! Sit up straight!",
                "💺 Fix that posture! Your back will thank you!",
                "🧘 Time to adjust your posture!"
            ],
            'stretch': [
                "🧘‍♂️ Time for a quick stretch break!",
                "💪 Let's stretch those muscles!",
                "🤸 Stand up and stretch!"
            ]
        }

    def _setup_handlers(self) -> None:
        self.handlers = {
            'hydrate_reward': self.handle_hydrate,
            'posture_reward': self.handle_posture,
            'stretch_reward': self.handle_stretch
        }

    async def handle_hydrate(self, ctx, user: str, _: str) -> None:
        await self.send_random_message(ctx, 'hydrate', user=user)
        await self.bot.analytics.log_reward('hydrate')

    async def handle_posture(self, ctx, user: str, _: str) -> None:
        await self.send_random_message(ctx, 'posture', user=user)
        await self.bot.analytics.log_reward('posture')

    async def handle_stretch(self, ctx, user: str, _: str) -> None:
        await self.send_random_message(ctx, 'stretch', user=user)
        await self.bot.analytics.log_reward('stretch')

================
File: features/tracking/user_tracker.py
================
# features/tracking/user_tracker.py
import logging
import asyncio
from typing import Dict, List, Optional
from datetime import datetime, timedelta, timezone
from dataclasses import dataclass
from sqlalchemy import text

logger = logging.getLogger(__name__)

@dataclass
class UserActivity:
    first_seen: datetime
    last_seen: datetime
    message_count: int = 0
    time_watched: int = 0  # in minutes
    last_message: Optional[str] = None
    is_subscriber: bool = False
    is_moderator: bool = False
    custom_badges: List[str] = None

    def __post_init__(self):
        if self.custom_badges is None:
            self.custom_badges = []

class UserTracker:
    def __init__(self, bot):
        self.bot = bot
        self.active_users: Dict[str, UserActivity] = {}
        self.session_start = datetime.now(timezone.utc)
        self.first_time_chatters: set = set()
        self.returning_users: set = set()
        self._lock = asyncio.Lock()

    async def track_user_message(self, message) -> bool:
        """Track a user's message and return whether they're a first-time chatter"""
        user_id = str(message.author.id)
        username = message.author.name
        is_first_time = False

        async with self._lock:
            try:
                # Check if user exists in database
                is_first_time = await self._is_first_time_chatter(user_id)
                
                # Update or create activity record
                if user_id not in self.active_users:
                    self.active_users[user_id] = UserActivity(
                        first_seen=datetime.now(timezone.utc),
                        last_seen=datetime.now(timezone.utc),
                        is_subscriber=message.author.is_subscriber,
                        is_moderator=message.author.is_mod
                    )
                    if is_first_time:
                        self.first_time_chatters.add(user_id)
                    else:
                        self.returning_users.add(user_id)

                # Update activity
                activity = self.active_users[user_id]
                activity.last_seen = datetime.now(timezone.utc)
                activity.message_count += 1
                activity.last_message = message.content
                activity.is_subscriber = message.author.is_subscriber
                activity.is_moderator = message.author.is_mod

                # Update database
                await self._update_user_db(user_id, username, activity)
                
                return is_first_time
                
            except Exception as e:
                logger.error(f"Error tracking user message: {e}")
                return False

    async def _is_first_time_chatter(self, user_id: str) -> bool:
        """Check if this is a user's first time chatting"""
        try:
            async with self.bot.db.session_scope() as session:
                stmt = text("SELECT first_seen FROM users WHERE twitch_id = :user_id")
                result = await session.execute(stmt, {'user_id': user_id})
                row = result.first()
                return row is None
        except Exception as e:
            logger.error(f"Error checking first time chatter: {e}")
            return False

    async def _update_user_db(self, user_id: str, username: str, activity: UserActivity):
        """Update user information in database"""
        try:
            async with self.bot.db.session_scope() as session:
                stmt = text("""
                    INSERT INTO users (
                        twitch_id, username, first_seen, last_seen, 
                        is_subscriber, is_moderator
                    ) VALUES (
                        :user_id, :username, :first_seen, :last_seen,
                        :is_subscriber, :is_moderator
                    )
                    ON CONFLICT (twitch_id) DO UPDATE SET
                        username = :username,
                        last_seen = :last_seen,
                        is_subscriber = :is_subscriber,
                        is_moderator = :is_moderator
                """)
                
                await session.execute(stmt, {
                    'user_id': user_id,
                    'username': username,
                    'first_seen': activity.first_seen,
                    'last_seen': activity.last_seen,
                    'is_subscriber': activity.is_subscriber,
                    'is_moderator': activity.is_moderator
                })
        except Exception as e:
            logger.error(f"Error updating user database: {e}")

    async def update_watch_time(self):
        """Update watch time for active users"""
        async with self._lock:
            current_time = datetime.now(timezone.utc)
            for user_id, activity in self.active_users.items():
                if (current_time - activity.last_seen) < timedelta(minutes=10):
                    activity.time_watched += 1

    async def get_user_stats(self, user_id: str) -> Optional[Dict]:
        """Get comprehensive stats for a user"""
        try:
            async with self.bot.db.session_scope() as session:
                stmt = text("""
                    SELECT 
                        username, first_seen, last_seen,
                        is_subscriber, is_moderator
                    FROM users 
                    WHERE twitch_id = :user_id
                """)
                result = await session.execute(stmt, {'user_id': user_id})
                row = result.first()
                
                if not row:
                    return None

                activity = self.active_users.get(user_id)
                
                return {
                    'username': row[0],
                    'first_seen': row[1],
                    'last_seen': row[2],
                    'is_subscriber': row[3],
                    'is_moderator': row[4],
                    'message_count': activity.message_count if activity else 0,
                    'time_watched': activity.time_watched if activity else 0
                }
        except Exception as e:
            logger.error(f"Error getting user stats: {e}")
            return None

    async def cleanup_inactive_users(self):
        """Remove users who haven't been active for a while"""
        async with self._lock:
            current_time = datetime.now(timezone.utc)
            inactive_threshold = timedelta(minutes=30)
            
            inactive_users = [
                user_id for user_id, activity in self.active_users.items()
                if (current_time - activity.last_seen) > inactive_threshold
            ]
            
            for user_id in inactive_users:
                del self.active_users[user_id]

    async def get_session_stats(self) -> Dict:
        """Get statistics for the current session"""
        return {
            'first_time_chatters': len(self.first_time_chatters),
            'returning_users': len(self.returning_users),
            'active_users': len(self.active_users),
            'total_messages': sum(u.message_count for u in self.active_users.values()),
            'subscribers': sum(1 for u in self.active_users.values() if u.is_subscriber),
            'session_duration': int((datetime.now(timezone.utc) - self.session_start).total_seconds() / 60)
        }

================
File: main.py
================
import os
import signal
import sys
import logging
from logging.handlers import RotatingFileHandler
import asyncio
from datetime import datetime, timezone

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.bot import TwitchBot
from features.commands.analytics import AnalyticsCommands
from features.commands.base import BaseCommands
from features.points.commands import PointsCommands
from config.config import Config
from database.manager import initialize_database

def setup_logging():
    """Configure logging for the bot"""
    if not os.path.exists('logs'):
        os.makedirs('logs')

    log_format = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

    file_handler = RotatingFileHandler(
        filename=f'logs/bot_{datetime.now().strftime("%Y-%m-%d")}.log',
        maxBytes=5000000,  # 5MB
        backupCount=5
    )
    file_handler.setFormatter(log_format)

    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(log_format)

    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    root_logger.addHandler(file_handler)
    root_logger.addHandler(console_handler)

def validate_environment():
    """Validate that all required environment variables are set"""
    try:
        Config.validate()
    except ValueError as e:
        logging.critical(f"Configuration error: {e}")
        sys.exit(1)

def setup_signal_handlers(bot):
    """Set up signal handlers for graceful shutdown"""
    import signal
    
    def handle_signal(signum, frame):
        logger.info(f"Received signal {signum}")
        asyncio.create_task(bot.close())
    
    signal.signal(signal.SIGINT, handle_signal)
    signal.signal(signal.SIGTERM, handle_signal)

def handle_signals(bot):
    """Set up signal handlers for graceful shutdown"""
    def signal_handler(*args):
        asyncio.create_task(shutdown(bot))
    
    for sig in (signal.SIGINT, signal.SIGTERM):
        signal.signal(sig, signal_handler)

async def shutdown(bot, signal_received=None):
    """Handle graceful shutdown"""
    if signal_received:
        logging.info(f"Received signal: {signal_received}")
    logging.info("Initiating shutdown sequence...")
    await bot.close()

async def main():
    """Main entry point for the bot"""
    try:
        # Set up logging
        setup_logging()
        logging.info("Starting bot...")

        # Validate environment
        validate_environment()

        # Initialize database
        await initialize_database("sqlite+aiosqlite:///bot.db")

        # Initialize bot
        bot = TwitchBot()
        
        # Set up signal handlers
        handle_signals(bot)
        
        # Start the bot
        logging.info("Bot initialized, connecting to Twitch...")
        await bot.start()

    except Exception as e:
        logging.critical(f"Fatal error: {e}", exc_info=True)
        if 'bot' in locals():
            try:
                await bot.close()
            except Exception as close_error:
                logging.error(f"Error during bot shutdown: {close_error}")
        sys.exit(1)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logging.info("Bot shutdown initiated by user")
    except Exception as e:
        logging.critical(f"Unexpected error: {e}", exc_info=True)
        sys.exit(1)

================
File: pytest.ini
================
# pytest.ini
[pytest]
asyncio_mode = auto
testpaths = tests
python_files = test_*.py
filterwarnings =
    ignore::DeprecationWarning
markers =
    asyncio: mark test as async

================
File: requirements-test.txt
================
pytest==7.4.3
pytest-asyncio==0.21.1
pytest-cov==4.1.0
aiosqlite==0.19.0
psutil==5.9.6
SQLAlchemy==2.0.23

================
File: requirements.txt
================
pytest==7.4.3
pytest-asyncio==0.21.1
pytest-cov==4.1.0
aiosqlite==0.19.0
psutil==5.9.6
SQLAlchemy==2.0.23

================
File: run_tests.py
================
# run_tests.py
import pytest
import sys

if __name__ == "__main__":
    args = [
        "-v",                # Verbose output
        "--asyncio-mode=auto",  # Handle async tests
        "tests",            # Test directory
        "--cov=.",          # Coverage report
        "--cov-report=term-missing"  # Show lines missing coverage
    ]
    result = pytest.main(args)
    sys.exit(result)

================
File: tests/__init__.py
================
# tests/__init__.py
# This can be empty, it just marks the directory as a Python package

================
File: tests/conftest.py
================
# tests/conftest.py
from contextlib import asynccontextmanager
import pytest
import asyncio
from unittest.mock import MagicMock, AsyncMock
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from database.models import Base
from utils.rate_limiter import RateLimiter
from features.analytics.tracker import AnalyticsTracker

import pytest
import asyncio
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from database.models import Base
import greenlet

@pytest.fixture
async def db():
    """Create test database with proper async setup"""
    engine = create_async_engine(
        "sqlite+aiosqlite:///:memory:",
        future=True,
        echo=False
    )
    
    async_session = sessionmaker(
        engine,
        class_=AsyncSession,
        expire_on_commit=False
    )
    
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    class TestDatabaseManager:
        def __init__(self):
            self.engine = engine
            self.Session = async_session
        
        @asynccontextmanager
        async def session_scope(self):
            """Provide a transactional scope around a series of operations."""
            session = self.Session()
            try:
                yield session
                await session.commit()
            except Exception:
                await session.rollback()
                raise
            finally:
                await session.close()

    yield TestDatabaseManager()
    
    # Cleanup
    await engine.dispose()

@pytest.fixture
def mock_bot(mock_db):
    """Create a mock bot instance for testing."""
    bot = MagicMock()
    bot.db = mock_db
    bot.rate_limiter = RateLimiter()
    bot.analytics = AnalyticsTracker(bot)

    # Mock context for command testing
    bot.ctx = AsyncMock()
    bot.ctx.send = AsyncMock()
    bot.ctx.author = MagicMock()
    bot.ctx.author.is_mod = False
    bot.ctx.author.name = "test_user"
    bot.ctx.author.id = "12345"

    return bot

# Add event loop fixture for Windows
@pytest.fixture(scope="session")
def event_loop():
    """Create an event loop for the test session."""
    policy = asyncio.get_event_loop_policy()
    loop = policy.new_event_loop()
    yield loop
    loop.close()

================
File: tests/test_analytics.py
================
import pytest
from datetime import datetime, timezone, timedelta
from unittest.mock import MagicMock, AsyncMock
from features.analytics.tracker import AnalyticsTracker
from collections import Counter, deque

@pytest.fixture
async def tracker():
    """Create a test analytics tracker"""
    bot = MagicMock()
    tracker = AnalyticsTracker(
        bot,
        max_command_history=10,
        max_reward_history=10,
        cleanup_interval=1
    )
    # Ensure tracker uses timezone-aware datetimes
    tracker.session_start = datetime.now(timezone.utc)
    return tracker

@pytest.mark.asyncio
async def test_analytics_cleanup(tracker):
    """Test cleanup of old analytics data"""
    # Add test data with timezone-aware dates
    now = datetime.now(timezone.utc)
    old_time = now - timedelta(days=2)
    
    tracker.command_history.clear()
    tracker.command_history.append((old_time, "old_command"))
    tracker.command_history.append((now, "new_command"))
    
    # Update command usage counters
    tracker.command_usage["old_command"] += 1
    tracker.command_usage["new_command"] += 1
    
    # Force cleanup with timezone-aware cutoff
    cutoff = now - timedelta(days=1)
    tracker.command_history = deque(
        (ts, cmd) for ts, cmd in tracker.command_history 
        if ts > cutoff
    )
    
    # Verify cleanup
    commands = [cmd for _, cmd in tracker.command_history]
    assert "new_command" in commands
    assert "old_command" not in commands

================
File: tests/test_cache.py
================
# tests/test_cache.py
import pytest
import asyncio
import time
from utils.cache_manager import CacheManager, cached

@pytest.mark.asyncio
async def test_cache_basic_operations():
    """Test basic cache operations"""
    cache = CacheManager(default_ttl=60)
    
    # Test set and get
    await cache.set("test_key", "test_value")
    value = await cache.get("test_key")
    assert value == "test_value"
    
    # Test delete
    await cache.delete("test_key")
    value = await cache.get("test_key")
    assert value is None

@pytest.mark.asyncio
async def test_cache_expiration():
    """Test cache expiration"""
    cache = CacheManager(default_ttl=1)  # 1 second TTL
    
    await cache.set("test_key", "test_value")
    value = await cache.get("test_key")
    assert value == "test_value"
    
    # Wait for expiration
    await asyncio.sleep(1.1)
    value = await cache.get("test_key")
    assert value is None

@pytest.mark.asyncio
async def test_cache_cleanup():
    """Test cache cleanup"""
    cache = CacheManager(default_ttl=1)
    
    # Add some items
    await cache.set("key1", "value1")
    await cache.set("key2", "value2")
    
    assert len(cache.cache) == 2
    
    # Wait for expiration
    await asyncio.sleep(1.1)
    await cache.cleanup()
    
    assert len(cache.cache) == 0

# Test the cached decorator
class MockDB:
    def __init__(self):
        self.cache_manager = CacheManager()
        self.call_count = 0

    @cached(ttl=1)
    async def expensive_operation(self, key):
        self.call_count += 1
        return f"result_{key}"

@pytest.mark.asyncio
async def test_cached_decorator():
    """Test the cached decorator"""
    db = MockDB()
    
    # First call should hit the database
    result1 = await db.expensive_operation("test")
    assert result1 == "result_test"
    assert db.call_count == 1
    
    # Second call should use cache
    result2 = await db.expensive_operation("test")
    assert result2 == "result_test"
    assert db.call_count == 1
    
    # Wait for cache expiration
    await asyncio.sleep(1.1)
    
    # This call should hit the database again
    result3 = await db.expensive_operation("test")
    assert result3 == "result_test"
    assert db.call_count == 2

================
File: tests/test_command_storage.py
================
# tests/test_command_storage.py
import pytest
from sqlalchemy import text

@pytest.mark.asyncio
async def test_add_command(db):
    """Test storing and retrieving commands"""
    create_table = text('''
        CREATE TABLE IF NOT EXISTS commands (
            name TEXT PRIMARY KEY,
            response TEXT NOT NULL
        )
    ''')

    insert_command = text('INSERT INTO commands (name, response) VALUES (:name, :response)')
    select_command = text('SELECT response FROM commands WHERE name = :name')

    async with db.session_scope() as session:
        # Create commands table if it doesn't exist
        await session.execute(create_table)
        await session.commit()

        # Add command
        await session.execute(insert_command, 
            {'name': '!test', 'response': 'Test response'}
        )
        await session.commit()
        
        # Verify command exists
        result = await session.execute(select_command, 
            {'name': '!test'}
        )
        row = result.first()
        assert row[0] == 'Test response'

@pytest.mark.asyncio
async def test_update_command(db):
    """Test updating an existing command"""
    insert_command = text('INSERT INTO commands (name, response) VALUES (:name, :response)')
    update_command = text('UPDATE commands SET response = :response WHERE name = :name')
    select_command = text('SELECT response FROM commands WHERE name = :name')

    async with db.session_scope() as session:
        # Add initial command
        await session.execute(insert_command,
            {'name': '!test', 'response': 'Original response'}
        )
        await session.commit()
        
        # Update command
        await session.execute(update_command,
            {'name': '!test', 'response': 'Updated response'}
        )
        await session.commit()
        
        # Verify update
        result = await session.execute(select_command,
            {'name': '!test'}
        )
        row = result.first()
        assert row[0] == 'Updated response'

@pytest.mark.asyncio
async def test_delete_command(db):
    """Test deleting a command"""
    insert_command = text('INSERT INTO commands (name, response) VALUES (:name, :response)')
    delete_command = text('DELETE FROM commands WHERE name = :name')
    count_command = text('SELECT COUNT(*) FROM commands WHERE name = :name')

    async with db.session_scope() as session:
        # Add command
        await session.execute(insert_command,
            {'name': '!test', 'response': 'Test response'}
        )
        await session.commit()
        
        # Delete command
        await session.execute(delete_command,
            {'name': '!test'}
        )
        await session.commit()
        
        # Verify deletion
        result = await session.execute(count_command,
            {'name': '!test'}
        )
        row = result.first()
        assert row[0] == 0

@pytest.mark.asyncio
async def test_command_case_sensitivity(db):
    """Test command name case sensitivity handling"""
    insert_command = text('INSERT INTO commands (name, response) VALUES (:name, :response)')
    select_command = text('SELECT response FROM commands WHERE LOWER(name) = LOWER(:name)')

    async with db.session_scope() as session:
        # Add command with uppercase
        await session.execute(insert_command,
            {'name': '!TEST', 'response': 'Test response'}
        )
        await session.commit()
        
        # Should find command case-insensitively
        result = await session.execute(select_command,
            {'name': '!test'}
        )
        row = result.first()
        assert row[0] == 'Test response'

================
File: tests/test_command_usage.py
================
# tests/test_command_usage.py
import pytest
from sqlalchemy import text
from datetime import datetime, timedelta, timezone

# Define SQL statements
CREATE_TABLE = text('''
    CREATE TABLE IF NOT EXISTS command_usage (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        command_name TEXT NOT NULL,
        user_id TEXT NOT NULL,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        success BOOLEAN DEFAULT TRUE
    )
''')

INSERT_COMMAND = text('INSERT INTO command_usage (command_name, user_id) VALUES (:command, :user_id)')
INSERT_COMMAND_WITH_TIME = text('''
    INSERT INTO command_usage (command_name, user_id, timestamp) 
    VALUES (:command, :user_id, :timestamp)
''')
INSERT_COMMAND_WITH_SUCCESS = text('''
    INSERT INTO command_usage (command_name, user_id, success) 
    VALUES (:command, :user_id, :success)
''')

COUNT_ALL = text('SELECT COUNT(*) FROM command_usage')
COUNT_BY_USER = text('SELECT COUNT(*) FROM command_usage WHERE user_id = :user_id')
COUNT_RECENT = text('SELECT COUNT(*) FROM command_usage WHERE timestamp > :since')
GET_SUCCESS_STATS = text('''
    SELECT 
        COUNT(*) as total,
        SUM(CASE WHEN success THEN 1 ELSE 0 END) as successes
    FROM command_usage 
    WHERE command_name = :command
''')
GET_USAGE_RANKING = text('''
    SELECT command_name, COUNT(*) as usage_count
    FROM command_usage
    GROUP BY command_name
    ORDER BY usage_count DESC
''')

@pytest.mark.asyncio
async def test_log_command_usage(db):
    """Test logging command usage"""
    async with db.session_scope() as session:
        # Create table
        await session.execute(CREATE_TABLE)
        await session.commit()

        # Log command usage
        await session.execute(INSERT_COMMAND, 
            {'command': '!test', 'user_id': '12345'}
        )
        await session.commit()
        
        # Verify usage was logged
        result = await session.execute(COUNT_ALL)
        row = result.first()
        assert row[0] == 1

@pytest.mark.asyncio
async def test_get_user_command_count(db):
    """Test getting command usage count for a user"""
    async with db.session_scope() as session:
        # Create table
        await session.execute(CREATE_TABLE)
        await session.commit()

        # Log multiple uses
        for _ in range(3):
            await session.execute(INSERT_COMMAND,
                {'command': '!test', 'user_id': '12345'}
            )
        await session.commit()
        
        # Get count for user
        result = await session.execute(COUNT_BY_USER,
            {'user_id': '12345'}
        )
        row = result.first()
        assert row[0] == 3

@pytest.mark.asyncio
async def test_get_recent_command_usage(db):
    """Test getting recent command usage"""
    current_time = datetime.now(timezone.utc)
    
    async with db.session_scope() as session:
        # Create table
        await session.execute(CREATE_TABLE)
        await session.commit()

        # Add some usage data with timestamps
        await session.execute(INSERT_COMMAND_WITH_TIME,
            {
                'command': '!test', 
                'user_id': '12345',
                'timestamp': current_time - timedelta(minutes=5)
            }
        )
        await session.commit()
        
        # Get recent usage (last 10 minutes)
        result = await session.execute(COUNT_RECENT,
            {'since': current_time - timedelta(minutes=10)}
        )
        row = result.first()
        assert row[0] == 1

@pytest.mark.asyncio
async def test_command_success_tracking(db):
    """Test tracking command execution success/failure"""
    async with db.session_scope() as session:
        # Create table
        await session.execute(CREATE_TABLE)
        await session.commit()

        # Log successful usage
        await session.execute(INSERT_COMMAND_WITH_SUCCESS,
            {'command': '!test', 'user_id': '12345', 'success': True}
        )
        
        # Log failed usage
        await session.execute(INSERT_COMMAND_WITH_SUCCESS,
            {'command': '!test', 'user_id': '12345', 'success': False}
        )
        await session.commit()
        
        # Get success rate
        result = await session.execute(GET_SUCCESS_STATS,
            {'command': '!test'}
        )
        row = result.first()
        assert row[0] == 2  # total
        assert row[1] == 1  # successes

@pytest.mark.asyncio
async def test_most_used_commands(db):
    """Test getting most frequently used commands"""
    async with db.session_scope() as session:
        # Create table
        await session.execute(CREATE_TABLE)
        await session.commit()

        # Log varying usage
        for _ in range(3):
            await session.execute(INSERT_COMMAND,
                {'command': '!test', 'user_id': '12345'}
            )
        
        await session.execute(INSERT_COMMAND,
            {'command': '!other', 'user_id': '12345'}
        )
        await session.commit()
        
        # Get command usage ranking
        result = await session.execute(GET_USAGE_RANKING)
        rows = result.fetchall()
        assert rows[0][0] == '!test'  # Most used command
        assert rows[0][1] == 3        # Used 3 times
        assert rows[1][0] == '!other' # Second most used
        assert rows[1][1] == 1        # Used once

================
File: tests/test_database_cache.py
================
import pytest
import asyncio
from datetime import datetime
from sqlalchemy import text
from database.models import CustomCommand, User, Base

@pytest.fixture
async def db():
    """Set up test database with cache"""
    from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
    from sqlalchemy.orm import sessionmaker
    
    engine = create_async_engine('sqlite+aiosqlite:///:memory:', echo=False)
    async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
    
    class TestDatabaseManager:
        def __init__(self):
            self.engine = engine
            self.session_maker = async_session
            self.cache = {}
        
        async def get_command(self, name: str) -> CustomCommand:
            async with self.session_maker() as session:
                result = await session.execute(
                    text('SELECT name, response FROM commands WHERE name = :name'),
                    {'name': name}
                )
                row = await result.first()
                if row:
                    return CustomCommand(name=row[0], response=row[1])
                return None

        async def add_command(self, name: str, response: str) -> CustomCommand:
            async with self.session_maker() as session:
                await session.execute(
                    text('INSERT OR REPLACE INTO commands (name, response) VALUES (:name, :response)'),
                    {'name': name, 'response': response}
                )
                await session.commit()
                return CustomCommand(name=name, response=response)

        async def get_or_create_user(self, twitch_id: str, username: str) -> User:
            async with self.session_maker() as session:
                result = await session.execute(
                    text('SELECT twitch_id, username FROM users WHERE twitch_id = :twitch_id'),
                    {'twitch_id': twitch_id}
                )
                row = await result.first()
                if not row:
                    await session.execute(
                        text('INSERT INTO users (twitch_id, username) VALUES (:twitch_id, :username)'),
                        {'twitch_id': twitch_id, 'username': username}
                    )
                    await session.commit()
                    return User(twitch_id=twitch_id, username=username)
                return User(twitch_id=row[0], username=row[1])

    # Create tables
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
        
        # Create initial schema
        await conn.execute(text('''
            CREATE TABLE IF NOT EXISTS commands (
                name TEXT PRIMARY KEY,
                response TEXT NOT NULL
            )
        '''))
        
        await conn.execute(text('''
            CREATE TABLE IF NOT EXISTS users (
                twitch_id TEXT PRIMARY KEY,
                username TEXT NOT NULL
            )
        '''))

    db = TestDatabaseManager()
    yield db
    
    await engine.dispose()

@pytest.mark.asyncio
async def test_cached_command_retrieval(db):
    """Test command caching"""
    async with db.session_maker() as session:
        # Create initial command
        await session.execute(
            text('INSERT INTO commands (name, response) VALUES (:name, :response)'),
            {'name': 'test', 'response': 'test response'}
        )
        await session.commit()
    
    # First get should hit database
    async with db.session_maker() as session:
        result = await session.execute(
            text('SELECT response FROM commands WHERE name = :name'),
            {'name': 'test'}
        )
        row = result.first()
        assert row is not None
        assert row[0] == 'test response'
    
    # Second get should also work
    async with db.session_maker() as session:
        result = await session.execute(
            text('SELECT response FROM commands WHERE name = :name'),
            {'name': 'test'}
        )
        row = result.first()
        assert row is not None
        assert row[0] == 'test response'

@pytest.mark.asyncio
async def test_cache_invalidation(db):
    """Test cache invalidation on command update"""
    async with db.session_maker() as session:
        # Create initial command
        await session.execute(
            text('INSERT INTO commands (name, response) VALUES (:name, :response)'),
            {'name': 'test', 'response': 'initial response'}
        )
        await session.commit()
    
    # First get
    async with db.session_maker() as session:
        result = await session.execute(
            text('SELECT response FROM commands WHERE name = :name'),
            {'name': 'test'}
        )
        row = result.first()
        assert row[0] == 'initial response'
    
    # Update command
    async with db.session_maker() as session:
        await session.execute(
            text('UPDATE commands SET response = :response WHERE name = :name'),
            {'name': 'test', 'response': 'updated response'}
        )
        await session.commit()
    
    # Get updated response
    async with db.session_maker() as session:
        result = await session.execute(
            text('SELECT response FROM commands WHERE name = :name'),
            {'name': 'test'}
        )
        row = result.first()
        assert row[0] == 'updated response'

@pytest.mark.asyncio
async def test_cached_user_retrieval(db):
    """Test user caching"""
    async with db.session_maker() as session:
        # Add initial user
        await session.execute(
            text('INSERT INTO users (twitch_id, username) VALUES (:id, :name)'),
            {'id': '12345', 'name': 'test_user'}
        )
        await session.commit()
    
    # First get
    async with db.session_maker() as session:
        result = await session.execute(
            text('SELECT username FROM users WHERE twitch_id = :id'),
            {'id': '12345'}
        )
        row = result.first()
        assert row is not None
        assert row[0] == 'test_user'

================
File: tests/test_database_pool.py
================
import pytest
import asyncio
from sqlalchemy import text
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from database.models import Base

@pytest.fixture
async def db():
    """Create test database"""
    engine = create_async_engine('sqlite+aiosqlite:///:memory:', echo=False)
    async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

    class TestDatabaseManager:
        def __init__(self):
            self.engine = engine
            self.session_maker = async_session

    # Create tables
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
        # Create test tables
        await conn.execute(text('''
            CREATE TABLE IF NOT EXISTS commands (
                name TEXT PRIMARY KEY,
                response TEXT NOT NULL
            )
        '''))
        await conn.execute(text('''
            CREATE TABLE IF NOT EXISTS users (
                twitch_id TEXT PRIMARY KEY,
                username TEXT NOT NULL
            )
        '''))

    yield TestDatabaseManager()
    await engine.dispose()

@pytest.mark.asyncio
async def test_command_storage(db):
    """Test storing and retrieving commands"""
    async with db.session_maker() as session:
        # Create command
        await session.execute(
            text('INSERT INTO commands (name, response) VALUES (:name, :response)'),
            {'name': '!test', 'response': 'Test response'}
        )
        await session.commit()
        
        # Retrieve command
        result = await session.execute(
            text('SELECT response FROM commands WHERE name = :name'),
            {'name': '!test'}
        )
        row = result.first()
        assert row[0] == 'Test response'

@pytest.mark.asyncio
async def test_user_data(db):
    """Test user data operations"""
    async with db.session_maker() as session:
        # Add user
        await session.execute(
            text('INSERT INTO users (twitch_id, username) VALUES (:id, :name)'),
            {'id': '12345', 'name': 'testuser'}
        )
        await session.commit()
        
        # Get user
        result = await session.execute(
            text('SELECT username FROM users WHERE twitch_id = :id'),
            {'id': '12345'}
        )
        row = result.first()
        assert row[0] == 'testuser'

@pytest.mark.asyncio
async def test_basic_concurrent_access(db):
    """Test simple concurrent operations"""
    async def add_user(user_id: str, username: str):
        async with db.session_maker() as session:
            await session.execute(
                text('INSERT INTO users (twitch_id, username) VALUES (:id, :name)'),
                {'id': user_id, 'name': username}
            )
            await session.commit()
    
    # Add users concurrently
    await asyncio.gather(
        add_user('1', 'user1'),
        add_user('2', 'user2'),
        add_user('3', 'user3')
    )
    
    # Verify all users were added
    async with db.session_maker() as session:
        result = await session.execute(text('SELECT COUNT(*) FROM users'))
        row = result.first()
        assert row[0] == 3

================
File: tests/test_database.py
================
import pytest
import asyncio
from datetime import datetime
from unittest.mock import Base, MagicMock, AsyncMock
from sqlalchemy import text
from database.models import User, StreamStats

class MockDatabaseManager:
    def __init__(self, engine, session_maker):
        self.engine = engine
        self.session_maker = session_maker
        self.user_batch_manager = MagicMock()
        self.user_batch_manager.flush = AsyncMock()
        self.stream_stats_manager = MagicMock()
        self.stream_stats_manager.update_viewer_count = AsyncMock()
        self.stream_stats_manager.increment_messages = AsyncMock()
        self.stream_stats_manager.flush = AsyncMock()

    async def get_or_create_user(self, twitch_id: str, username: str) -> User:
        async with self.session_maker() as session:
            user = await session.execute(
                text('SELECT * FROM users WHERE twitch_id = :twitch_id'),
                {'twitch_id': twitch_id}
            )
            user = user.first()
            if not user:
                user = User(twitch_id=twitch_id, username=username)
                session.add(user)
                await session.commit()
            return user

    async def add_command(self, name: str, response: str):
        async with self.session_maker() as session:
            await session.execute(
                text('INSERT INTO commands (name, response) VALUES (:name, :response)'),
                {'name': name, 'response': response}
            )
            await session.commit()
            return True

@pytest.fixture
async def db():
    """Create test database"""
    from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
    from sqlalchemy.orm import sessionmaker
    
    engine = create_async_engine('sqlite+aiosqlite:///:memory:', echo=False)
    async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
    
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    manager = MockDatabaseManager(engine, async_session)
    yield manager
    
    await engine.dispose()

================
File: tests/test_error_recovery.py
================
# tests/test_error_recovery.py
import pytest
import asyncio
from sqlalchemy import text
from sqlalchemy.exc import SQLAlchemyError

# Define SQL statements
CREATE_TABLE = text('''
    CREATE TABLE IF NOT EXISTS commands (
        name TEXT PRIMARY KEY,
        response TEXT NOT NULL
    )
''')

INSERT_COMMAND = text('INSERT INTO commands (name, response) VALUES (:name, :response)')
COUNT_COMMANDS = text('SELECT COUNT(*) FROM commands')

@pytest.mark.asyncio
async def test_transaction_rollback(db):
    """Test database recovery after failed transaction."""
    async with db.session_scope() as session:
        # Create table and insert initial command
        await session.execute(CREATE_TABLE)
        await session.execute(INSERT_COMMAND,
            {'name': '!test', 'response': 'Test response'}
        )
        await session.commit()

    try:
        async with db.session_scope() as session:
            await session.execute(INSERT_COMMAND,
                {'name': '!test2', 'response': 'Test 2'}
            )
            raise SQLAlchemyError("Simulated error")
    except SQLAlchemyError:
        pass

    async with db.session_scope() as session:
        result = await session.execute(COUNT_COMMANDS)
        row = result.first()
        assert row[0] == 1  # Only first command should exist

@pytest.mark.asyncio
async def test_connection_loss_recovery(db):
    """Test recovery from connection loss."""
    async with db.session_scope() as session:
        # Verify we can execute queries
        result = await session.execute(COUNT_COMMANDS)
        row = result.first()
        assert row[0] is not None

@pytest.mark.asyncio
async def test_concurrent_error_isolation(db):
    """Test that errors in one operation don't affect others."""
    async def good_operation():
        async with db.session_scope() as session:
            await session.execute(INSERT_COMMAND,
                {'name': '!good', 'response': 'Good'}
            )
            await session.commit()
            return True

    async def bad_operation():
        try:
            async with db.session_scope() as session:
                raise SQLAlchemyError("Simulated bad operation")
        except SQLAlchemyError:
            return False
        return True

    results = await asyncio.gather(
        good_operation(),
        bad_operation(),
        return_exceptions=True
    )
    
    assert results[0] is True  # good operation succeeded
    assert results[1] is False  # bad operation failed as expected

    async with db.session_scope() as session:
        result = await session.execute(COUNT_COMMANDS)
        row = result.first()
        assert row[0] == 1  # Only good operation's command should exist

@pytest.mark.asyncio
async def test_reconnection_attempt(db):
    """Test database reconnection attempts."""
    retries = 3
    success = False

    for _ in range(retries):
        try:
            async with db.session_scope() as session:
                result = await session.execute(COUNT_COMMANDS)
                row = result.first()
                assert row[0] is not None
                success = True
                break
        except SQLAlchemyError:
            await asyncio.sleep(0.1)

    assert success, "Should successfully reconnect within retry attempts"

================
File: tests/test_raid_points.py
================
import pytest
import asyncio
from unittest.mock import MagicMock, AsyncMock, call
from core.raid_points import RaidPointsManager

class TestRaidPointsSystem:
    @pytest.fixture
    def points_manager(self):  # Remove async from fixture
        bot = MagicMock()
        bot.points_manager = AsyncMock()
        bot.points_manager.get_points.return_value = 1000
        bot.points_manager.remove_points.return_value = True
        bot.points_manager.add_points.return_value = True
        
        session = AsyncMock()
        result = AsyncMock()
        result.first.return_value = [1500, 2000, 3]
        session.execute.return_value = result
        
        bot.db = AsyncMock()
        context_manager = AsyncMock()
        context_manager.__aenter__ = AsyncMock(return_value=session)
        context_manager.__aexit__ = AsyncMock()
        bot.db.session_scope.return_value = context_manager
        
        return RaidPointsManager(bot)

    @pytest.mark.asyncio
    async def test_investment_stats(self, points_manager):
        # Mock database session and query execution
        session = AsyncMock()
        mock_result = AsyncMock()
        mock_result.fetchone = AsyncMock(return_value=(1500, 2000, 3))  # Mocked data
        session.execute.return_value = mock_result  # Ensure execute() returns the mocked result object

        # Mock session_scope as async context manager
        context_manager = AsyncMock()
        context_manager.__aenter__.return_value = session
        context_manager.__aexit__.return_value = None
        points_manager.bot.db.session_scope = MagicMock(return_value=context_manager)

        # Call the method being tested
        stats = await points_manager.get_investment_stats("user1")
        expected = {
            'total_invested': 1500,
            'total_rewards': 2000,
            'total_raids': 3,
            'roi': (2000 - 1500) / 1500
        }

        # Assert the result matches the expected output
        assert stats == expected





    @pytest.mark.asyncio
    async def test_transaction_atomicity(self, points_manager):
        # Mock session and its methods
        session = AsyncMock()
        session.commit = AsyncMock(side_effect=Exception("Database error"))  # Simulate commit failure
        session.rollback = AsyncMock()  # Rollback should be called

        # Mock session_scope as an async context manager
        context_manager = AsyncMock()
        context_manager.__aenter__.return_value = session
        context_manager.__aexit__.return_value = None  # No-op for exit
        points_manager.bot.db.session_scope = MagicMock(return_value=context_manager)  # NOT AsyncMock

        # Mock points_manager methods
        points_manager.bot.points_manager.get_points = AsyncMock(return_value=1000)  # User has 1000 points
        points_manager.bot.points_manager.remove_points = AsyncMock(return_value=True)  # Simulate successful removal
        points_manager.refund_investment = AsyncMock(return_value=True)  # Refund is successful

        # Call process_investment
        success, message = await points_manager.process_investment("user1", 500)

        # Assertions
        assert not success, "Transaction should fail if commit raises an exception"
        assert "Error processing investment" in message
        session.rollback.assert_called_once()  # Ensure rollback was triggered
        points_manager.refund_investment.assert_called_once_with("user1", 500, "Database error")

================
File: tests/test_raid_rewards.py
================
import pytest
from unittest.mock import MagicMock, AsyncMock, call
from core.raid_rewards import RaidRewardManager
from core.raid_states import RaidState

class TestRaidRewardDistribution:
    @pytest.fixture
    def mock_bot(self):  # Remove async
        bot = MagicMock()
        bot.points_manager = AsyncMock()
        bot.points_manager.add_points.return_value = True
        
        session = AsyncMock()
        session.execute = AsyncMock()
        session.commit = AsyncMock()
        
        bot.db = AsyncMock()
        context_manager = AsyncMock()
        context_manager.__aenter__ = AsyncMock(return_value=session)
        context_manager.__aexit__ = AsyncMock()
        bot.db.session_scope.return_value = context_manager
        
        return bot

    @pytest.fixture
    def raid_instance(self):  # Renamed from sample_raid_instance
        instance = MagicMock()
        instance.ship_type = "Merchant Vessel"
        instance.current_multiplier = 1.5
        instance.state = RaidState.ACTIVE
        instance.start_time = "2023-01-01"
        
        rewards = {
            "user1": 750,  # 500 * 1.5
            "user2": 1125, # 750 * 1.5
            "user3": 1500  # 1000 * 1.5
        }
        instance.get_rewards = MagicMock(return_value=rewards)
        
        instance.participants = {
            "user1": MagicMock(total_investment=500, initial_investment=500),
            "user2": MagicMock(total_investment=750, initial_investment=750),
            "user3": MagicMock(total_investment=1000, initial_investment=1000)
        }
        
        return instance

    @pytest.mark.asyncio
    async def test_basic_reward_distribution(self, mock_bot, raid_instance):
        reward_manager = RaidRewardManager(mock_bot)
        success, _ = await reward_manager.distribute_rewards(raid_instance)

        assert success, "Reward distribution should be successful"
        assert mock_bot.points_manager.add_points.call_count == len(raid_instance.participants)

        expected_calls = [
            call("user1", 750, f"Raid reward ({raid_instance.ship_type})"),
            call("user2", 1125, f"Raid reward ({raid_instance.ship_type})"),
            call("user3", 1500, f"Raid reward ({raid_instance.ship_type})")
        ]
        mock_bot.points_manager.add_points.assert_has_calls(expected_calls, any_order=True)

    @pytest.mark.asyncio
    async def test_empty_raid_handling(self, mock_bot):
        # Create an empty raid instance
        empty_raid = MagicMock()
        empty_raid.participants = {}  # No participants
        empty_raid.state = RaidState.ACTIVE
        empty_raid.get_rewards = MagicMock(return_value={})
        empty_raid.ship_type = "Empty Ship"

        reward_manager = RaidRewardManager(mock_bot)
        success, message = await reward_manager.distribute_rewards(empty_raid)

        # Assert that the distribution fails
        assert not success, "Reward distribution should fail for empty raids"
        assert "No participants" in str(message), f"Unexpected error message: {message}"

    @pytest.mark.asyncio
    async def test_invalid_state_distribution(self, mock_bot, raid_instance):
        raid_instance.state = RaidState.RECRUITING  # Set an invalid state

        reward_manager = RaidRewardManager(mock_bot)
        success, message = await reward_manager.distribute_rewards(raid_instance)

        # Assertions
        assert not success, "Reward distribution should fail for invalid raid state."
        assert "Invalid state" in message, f"Unexpected message: {message}"


    @pytest.mark.asyncio
    async def test_multiplier_reward_calculation(self, mock_bot, raid_instance):
        raid_instance.current_multiplier = 2.0
        rewards = {
            "user1": 1000,  # 500 * 2.0
            "user2": 1500,  # 750 * 2.0
            "user3": 2000   # 1000 * 2.0
        }
        raid_instance.get_rewards = MagicMock(return_value=rewards)
        
        reward_manager = RaidRewardManager(mock_bot)
        success, _ = await reward_manager.distribute_rewards(raid_instance)
        
        assert success
        reward_amounts = [args[1] for args, _ in mock_bot.points_manager.add_points.call_args_list]
        assert max(reward_amounts) == 2000

================
File: tests/test_raid_system.py
================
import pytest
from unittest.mock import AsyncMock, MagicMock
from core.raid_states import RaidState, RaidInstance
from core.raid_errors import RaidStateError

class TestRaidStateTransitions:
    @pytest.fixture
    async def raid_instance(self):
        instance = MagicMock()
        instance.state = RaidState.RECRUITING
        instance.validate_state_transition = AsyncMock()
        instance.validate_state_transition.side_effect = RaidStateError("Invalid state transition")
        return instance

    @pytest.mark.asyncio
    async def test_invalid_state_transitions(self, raid_instance):
        raid_instance.state = RaidState.COMPLETED
        
        with pytest.raises(RaidStateError) as exc_info:
            await raid_instance.validate_state_transition(RaidState.RECRUITING)
        
        assert "Invalid state transition" in str(exc_info.value)

================
File: tests/test_rate_limiting.py
================
# tests/test_rate_limiting.py
import pytest
import asyncio
from datetime import datetime, timedelta, timezone
from utils.rate_limiter import RateLimiter

@pytest.mark.asyncio
async def test_basic_rate_limiting():
    """Test basic rate limiting functionality"""
    limiter = RateLimiter()
    
    # First attempt should succeed
    can_execute, wait_time = await limiter.can_execute("test_command", "user1", cooldown=1)
    assert can_execute is True
    assert wait_time is None
    
    # Immediate second attempt should fail
    can_execute, wait_time = await limiter.can_execute("test_command", "user1", cooldown=1)
    assert can_execute is False
    assert wait_time > 0

    # Wait for cooldown
    await asyncio.sleep(1)

    # Third attempt should succeed
    can_execute, wait_time = await limiter.can_execute("test_command", "user1", cooldown=1)
    assert can_execute is True
    assert wait_time is None

@pytest.mark.asyncio
async def test_different_users():
    """Test rate limiting across different users"""
    limiter = RateLimiter()
    
    # First user triggers cooldown
    await limiter.can_execute("test_command", "user1", cooldown=3, global_cooldown=0)
    
    # Second user should still be able to execute (no global cooldown)
    can_execute, _ = await limiter.can_execute("test_command", "user2", cooldown=3, global_cooldown=0)
    assert can_execute is True

@pytest.mark.asyncio
async def test_concurrent_requests():
    """Test rate limiting under concurrent load"""
    limiter = RateLimiter()
    
    async def make_request(user_id):
        return await limiter.can_execute(
            "test_command", 
            f"user{user_id}", 
            cooldown=3, 
            global_cooldown=0
        )
    
    # Make multiple concurrent requests with different users
    results = await asyncio.gather(
        *[make_request(i) for i in range(10)]
    )
    
    # Each first attempt per user should succeed when no global cooldown
    assert all(can_execute for can_execute, _ in results)

@pytest.mark.asyncio
async def test_edge_cases():
    """Test edge cases and invalid inputs"""
    limiter = RateLimiter()
    
    # Test with empty command name
    can_execute, _ = await limiter.can_execute("", "user1")
    assert can_execute is True
    
    # Test with empty user id
    can_execute, _ = await limiter.can_execute("test_command", "")
    assert can_execute is True
    
    # Test with zero cooldown
    can_execute, _ = await limiter.can_execute(
        "test_command",
        "user1",
        cooldown=0,
        global_cooldown=0
    )
    assert can_execute is True

@pytest.mark.asyncio
async def test_cooldown_cleanup():
    """Test cleanup of old cooldowns"""
    limiter = RateLimiter()
    
    # Add some cooldowns
    await limiter.can_execute("test_command", "user1", cooldown=5)
    
    # Manually set old time
    old_time = datetime.now(timezone.utc) - timedelta(minutes=6)
    limiter.command_cooldowns["test_command"]["user1"] = old_time
    limiter.global_cooldowns["test_command"] = old_time
    
    # Trigger cleanup by making a new request
    await limiter.can_execute("other_command", "user2", cooldown=5)
    
    # Verify old cooldowns were cleaned up
    assert "test_command" not in limiter.command_cooldowns, "Old user cooldown not cleaned"
    assert "test_command" not in limiter.global_cooldowns, "Old global cooldown not cleaned"

@pytest.mark.asyncio
async def test_case_insensitivity():
    """Test case-insensitive command handling"""
    limiter = RateLimiter()
    
    # Set cooldown with uppercase command
    await limiter.can_execute("TEST_COMMAND", "user1")
    
    # Check with lowercase command
    can_execute, wait_time = await limiter.can_execute("test_command", "user1")
    assert can_execute is False
    assert wait_time > 0

@pytest.mark.asyncio
async def test_reset_cooldown():
    """Test cooldown reset functionality."""
    limiter = RateLimiter()
    command_name = "test_command"
    user_id = "user1"
    
    # First execution should succeed
    can_execute1, wait1 = await limiter.can_execute(command_name, user_id, cooldown=5, global_cooldown=0)
    assert can_execute1 is True, "First execution should succeed"
    assert wait1 is None, "First execution should have no wait time"
    
    # Verify cooldown is set
    assert command_name in limiter.command_cooldowns, "Command cooldown not set"
    assert user_id in limiter.command_cooldowns[command_name], "User cooldown not set"
    
    # Second execution should fail (on cooldown)
    can_execute2, wait2 = await limiter.can_execute(command_name, user_id, cooldown=5, global_cooldown=0)
    assert can_execute2 is False, "Should be on cooldown"
    assert wait2 > 0, "Should have wait time"
    
    # Reset the cooldown
    await limiter.reset_cooldown(command_name, user_id)
    
    # Verify cooldown is cleared
    assert command_name not in limiter.command_cooldowns or user_id not in limiter.command_cooldowns.get(command_name, {}), "Cooldown not properly reset"
    
    # Should be able to execute again after reset
    can_execute3, wait3 = await limiter.can_execute(command_name, user_id, cooldown=5, global_cooldown=0)
    assert can_execute3 is True, "Should work after cooldown reset"
    assert wait3 is None, "Should have no wait time after reset"

================
File: tests/test_rewards.py
================
# tests/test_rewards.py
import pytest
from unittest.mock import MagicMock, AsyncMock, patch
from features.rewards.handlers import RewardHandlers
from features.rewards.base_handler import BaseRewardHandler

@pytest.fixture
def mock_ctx():
    ctx = AsyncMock()
    ctx.channel = MagicMock()
    ctx.channel.name = "test_channel"
    ctx.channel.moderators = ["mod_user"]
    ctx.send = AsyncMock()
    return ctx

@pytest.fixture
def mock_bot():
    bot = MagicMock()
    bot.rewards = MagicMock()
    bot.get_channel = MagicMock()
    
    # Mock channel with moderators
    mock_channel = MagicMock()
    mock_channel.moderators = ["mod_user"]
    bot.get_channel.return_value = mock_channel
    
    # Mock analytics
    bot.analytics = MagicMock()
    bot.analytics.log_reward = AsyncMock()
    
    return bot

@pytest.mark.asyncio
async def test_reward_registration(mock_bot):
    """Test reward handler registration"""
    handlers = RewardHandlers(mock_bot)
    
    # Verify all rewards were registered
    registered_rewards = [args[0][0] for args in mock_bot.rewards.register_reward.call_args_list]
    expected_rewards = [
        'timeout_reward', 'emote_only', 'highlight_message',
        'channel_vip', 'hydrate', 'posture', 'stretch'
    ]
    
    for reward in expected_rewards:
        assert reward in registered_rewards

@pytest.mark.asyncio
async def test_timeout_reward(mock_bot, mock_ctx):
    """Test timeout reward handling"""
    handlers = RewardHandlers(mock_bot)

    # Test successful timeout
    await handlers.handle_timeout(mock_ctx, "redeemer", "target_user")

    assert mock_ctx.send.call_count == 1
    assert "timed out" in str(mock_ctx.send.call_args_list[0][0][0]).lower()

@pytest.mark.asyncio
async def test_timeout_reward_error_cases(mock_bot, mock_ctx):
    """Test timeout reward error handling"""
    handlers = RewardHandlers(mock_bot)

    # Test missing target
    with pytest.raises(ValueError, match="specify a user"):
        await handlers.handle_timeout(mock_ctx, "redeemer", None)

    # Test timeout on moderator
    mock_ctx.channel.moderators = ["mod_user"]
    with pytest.raises(ValueError, match="Cannot timeout moderators"):
        await handlers.handle_timeout(mock_ctx, "redeemer", "mod_user")

@pytest.mark.asyncio
async def test_emote_only_reward(mock_bot, mock_ctx):
    """Test emote-only mode reward"""
    handlers = RewardHandlers(mock_bot)

    await handlers.handle_emote_only(mock_ctx, "user", None)

    assert mock_ctx.send.call_count == 3
    assert "/emoteonly" in str(mock_ctx.send.call_args_list[0][0][0])
    assert "emote-only mode" in str(mock_ctx.send.call_args_list[1][0][0])

@pytest.mark.asyncio
async def test_base_reward_handler():
    """Test base reward handler functionality"""
    class TestHandler(BaseRewardHandler):
        def _setup_messages(self):
            self.messages = {
                'test': ['Test message for {user}!']
            }

        def _setup_handlers(self):
            self.handlers = {
                'test_reward': self.handle_test
            }

        async def handle_test(self, ctx, user, input_text):
            await self.send_random_message(ctx, 'test', user=user)

    mock_bot = MagicMock()
    mock_bot.analytics = MagicMock()
    mock_bot.analytics.log_reward = AsyncMock()  # Ensure this is awaitable

    handler = TestHandler(mock_bot)
    ctx = AsyncMock()

    await handler.handle_reward(ctx, 'test_reward', 'testuser', '')

    ctx.send.assert_called_once_with('Test message for testuser!')

@pytest.mark.asyncio
async def test_reward_error_handling(mock_bot, mock_ctx):
    """Test error handling in rewards"""
    handlers = RewardHandlers(mock_bot)

    # Force an error by passing None as target
    with pytest.raises(ValueError, match="You must specify a user to timeout."):
        await handlers.handle_timeout(mock_ctx, "user", None)

@pytest.mark.asyncio
async def test_input_validation():
    """Test reward input validation"""
    class TestHandler(BaseRewardHandler):
        def _setup_messages(self):
            self.messages = {}
        def _setup_handlers(self):
            self.handlers = {}
    
    handler = TestHandler(MagicMock())
    
    # Test valid input
    assert handler.validate_input("test") == "test"
    
    # Test empty input
    with pytest.raises(ValueError, match="provide valid input"):
        handler.validate_input("")
    
    # Test too long input
    long_input = "a" * 501
    with pytest.raises(ValueError, match="Input too long"):
        handler.validate_input(long_input)

@pytest.mark.asyncio
async def test_message_key_not_found(mock_bot, mock_ctx):
    """Test handling of missing message key"""
    class TestHandler(BaseRewardHandler):
        def _setup_messages(self):
            self.messages = {}
        def _setup_handlers(self):
            self.handlers = {}
    
    handler = TestHandler(mock_bot)
    await handler.send_random_message(mock_ctx, 'nonexistent_key')
    
    # Should send fallback message
    mock_ctx.send.assert_called_once_with("Action completed!")

================
File: tests/test_stream_analytics.py
================
# tests/test_stream_analytics.py
import asyncio
import pytest
from unittest.mock import MagicMock, AsyncMock
from features.analytics.tracker import AnalyticsTracker
from collections import Counter
from datetime import datetime, timedelta, timezone

@pytest.fixture
async def tracker():
    """Create a test analytics tracker"""
    bot = MagicMock()
    return AnalyticsTracker(
        bot,
        max_command_history=10,
        max_reward_history=10,
        cleanup_interval=1
    )

@pytest.mark.asyncio
async def test_command_logging(tracker):
    """Test basic command logging functionality"""
    # Log some commands
    await tracker.log_command("test_command")
    await tracker.log_command("test_command")
    await tracker.log_command("other_command")
    
    # Get stats
    stats = await tracker.get_stats()
    
    assert stats['commands']['total'] == 3
    assert stats['commands']['unique'] == 2
    most_used = dict(stats['commands']['most_used'])
    assert most_used['test_command'] == 2

@pytest.mark.asyncio
async def test_reward_logging(tracker):
    """Test reward logging functionality"""
    # Log some rewards
    await tracker.log_reward("test_reward")
    await tracker.log_reward("test_reward")
    await tracker.log_reward("other_reward")
    
    # Get stats
    stats = await tracker.get_stats()
    
    assert stats['rewards']['total'] == 3
    assert stats['rewards']['unique'] == 2
    most_used = dict(stats['rewards']['most_used'])
    assert most_used['test_reward'] == 2

@pytest.mark.asyncio
async def test_hourly_stats_tracking(tracker):
    """Test hourly statistics tracking"""
    current_time = datetime.now(timezone.utc)
    hour_key = current_time.strftime('%Y-%m-%d-%H')
    
    # Log activities
    await tracker.log_command("test_command")
    await tracker.log_reward("test_reward")
    
    # Verify hourly stats
    assert tracker.hourly_stats[hour_key]['commands_test_command'] == 1
    assert tracker.hourly_stats[hour_key]['rewards_test_reward'] == 1

@pytest.mark.asyncio
async def test_stats_with_time_window(tracker):
    """Test getting stats within a specific time window."""
    # Log some historical commands
    old_time = datetime.now(timezone.utc) - timedelta(hours=3)
    tracker.command_history.append((old_time, "old_command"))
    tracker.command_usage["old_command"] += 1

    current_time = datetime.now(timezone.utc)
    await tracker.log_command("new_command")

    # Get stats for last hour
    stats = await tracker.get_stats(hours=1)

    assert stats["commands"]["total"] == 1  # Only the new command
    assert stats["commands"]["unique"] == 1
    assert len(stats["commands"]["most_used"]) == 1
    assert stats["commands"]["most_used"][0][0] == "new_command"

@pytest.mark.asyncio
async def test_cleanup_old_data(tracker):
    """Test cleanup of old analytics data"""
    old_time = datetime.now(timezone.utc) - timedelta(days=8)
    old_key = old_time.strftime('%Y-%m-%d-%H')
    tracker.hourly_stats[old_key] = Counter({"test": 1})

    current_time = datetime.now(timezone.utc)
    current_key = current_time.strftime('%Y-%m-%d-%H')
    tracker.hourly_stats[current_key] = Counter({"test": 1})

    # Trigger cleanup
    await tracker._cleanup_old_data()

    assert old_key not in tracker.hourly_stats
    assert current_key in tracker.hourly_stats

@pytest.mark.asyncio
async def test_concurrent_logging(tracker):
    """Test concurrent logging of analytics data"""
    # Simulate concurrent logging
    tasks = []
    for _ in range(10):
        tasks.append(tracker.log_command("concurrent_command"))
    
    await asyncio.gather(*tasks)
    
    stats = await tracker.get_stats()
    assert stats['commands']['total'] == 10

@pytest.mark.asyncio
async def test_analytics_error_handling(tracker):
    """Test error handling in analytics tracking"""
    # Force an error by setting invalid data
    tracker.command_history = None
    
    # Should handle error gracefully
    stats = await tracker.get_stats()
    assert isinstance(stats, dict)
    assert stats == {
        'commands': {'total': 0, 'unique': 0, 'most_used': []},
        'rewards': {'total': 0, 'unique': 0, 'most_used': []}
    }

@pytest.mark.asyncio
async def test_hourly_stats_cleanup(tracker):
    """Test cleanup of old hourly stats."""
    old_time = datetime.now(timezone.utc) - timedelta(days=8)
    old_key = old_time.strftime('%Y-%m-%d-%H')
    tracker.hourly_stats[old_key] = Counter({"test": 1})

    current_time = datetime.now(timezone.utc)
    current_key = current_time.strftime('%Y-%m-%d-%H')
    tracker.hourly_stats[current_key] = Counter({"test": 1})

    # Trigger cleanup
    await tracker._cleanup_old_data()

    assert old_key not in tracker.hourly_stats
    assert current_key in tracker.hourly_stats

@pytest.mark.asyncio
async def test_most_active_hours(tracker):
    """Test analysis of most active hours."""
    base_time = datetime.now(timezone.utc).replace(hour=0, minute=0, second=0, microsecond=0)

    for hour in range(24):
        time = base_time + timedelta(hours=hour)
        hour_key = time.strftime('%Y-%m-%d-%H')
        tracker.hourly_stats[hour_key] = Counter({
            "commands_test": hour + 1  # More activity in later hours
        })

    active_hours = await tracker.get_peak_hours()

    assert len(active_hours) > 0
    assert active_hours[0]["hour"] == 23  # Latest hour has highest activity

================
File: tests/test_user_storage.py
================
# tests/test_user_storage.py
import pytest
from sqlalchemy import text
from datetime import datetime, timezone

# Define SQL statements
CREATE_TABLE = text('''
    CREATE TABLE IF NOT EXISTS users (
        twitch_id TEXT PRIMARY KEY,
        username TEXT NOT NULL,
        is_mod BOOLEAN DEFAULT FALSE,
        is_subscriber BOOLEAN DEFAULT FALSE,
        first_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
''')

INSERT_USER = text('INSERT INTO users (twitch_id, username) VALUES (:id, :name)')
SELECT_USERNAME = text('SELECT username FROM users WHERE twitch_id = :id')

UPDATE_MOD_STATUS = text('UPDATE users SET is_mod = TRUE WHERE twitch_id = :id')
SELECT_MOD_STATUS = text('SELECT is_mod FROM users WHERE twitch_id = :id')

UPDATE_SUB_STATUS = text('UPDATE users SET is_subscriber = TRUE WHERE twitch_id = :id')
SELECT_SUB_STATUS = text('SELECT is_subscriber FROM users WHERE twitch_id = :id')

UPDATE_LAST_SEEN = text('UPDATE users SET last_seen = :timestamp WHERE twitch_id = :id')
SELECT_LAST_SEEN = text('SELECT last_seen FROM users WHERE twitch_id = :id')

UPSERT_USER = text('''
    INSERT INTO users (twitch_id, username) 
    VALUES (:id, :name)
    ON CONFLICT (twitch_id) DO UPDATE SET 
        username = :name,
        last_seen = CURRENT_TIMESTAMP
''')

@pytest.mark.asyncio
async def test_add_user(db):
    """Test adding a new user"""
    async with db.session_scope() as session:
        # Create table
        await session.execute(CREATE_TABLE)
        await session.commit()

        # Add user
        await session.execute(INSERT_USER,
            {'id': '12345', 'name': 'testuser'}
        )
        await session.commit()
        
        # Verify user exists
        result = await session.execute(SELECT_USERNAME,
            {'id': '12345'}
        )
        row = result.first()
        assert row[0] == 'testuser'

@pytest.mark.asyncio
async def test_update_mod_status(db):
    """Test updating moderator status"""
    async with db.session_scope() as session:
        # Add user
        await session.execute(INSERT_USER,
            {'id': '12345', 'name': 'testuser'}
        )
        await session.commit()
        
        # Make user mod
        await session.execute(UPDATE_MOD_STATUS,
            {'id': '12345'}
        )
        await session.commit()
        
        # Verify mod status
        result = await session.execute(SELECT_MOD_STATUS,
            {'id': '12345'}
        )
        row = result.first()
        assert row[0] == 1  # SQLite represents TRUE as 1

@pytest.mark.asyncio
async def test_update_subscriber_status(db):
    """Test updating subscriber status"""
    async with db.session_scope() as session:
        # Add user
        await session.execute(INSERT_USER,
            {'id': '12345', 'name': 'testuser'}
        )
        await session.commit()
        
        # Make user subscriber
        await session.execute(UPDATE_SUB_STATUS,
            {'id': '12345'}
        )
        await session.commit()
        
        # Verify subscriber status
        result = await session.execute(SELECT_SUB_STATUS,
            {'id': '12345'}
        )
        row = result.first()
        assert row[0] == 1  # SQLite represents TRUE as 1

@pytest.mark.asyncio
async def test_update_last_seen(db):
    """Test updating user's last seen timestamp"""
    async with db.session_scope() as session:
        # Add user
        await session.execute(INSERT_USER,
            {'id': '12345', 'name': 'testuser'}
        )
        await session.commit()
        
        # Update last seen
        current_time = datetime.now(timezone.utc)
        await session.execute(UPDATE_LAST_SEEN,
            {'id': '12345', 'timestamp': current_time}
        )
        await session.commit()
        
        # Verify last seen was updated
        result = await session.execute(SELECT_LAST_SEEN,
            {'id': '12345'}
        )
        row = result.first()
        assert row[0] is not None

@pytest.mark.asyncio
async def test_get_or_create_user(db):
    """Test get or create user functionality"""
    async with db.session_scope() as session:
        # First time - should create
        await session.execute(UPSERT_USER,
            {'id': '12345', 'name': 'testuser'}
        )
        await session.commit()
        
        # Second time - should update
        await session.execute(UPSERT_USER,
            {'id': '12345', 'name': 'testuser_updated'}
        )
        await session.commit()
        
        # Verify final state
        result = await session.execute(SELECT_USERNAME,
            {'id': '12345'}
        )
        row = result.first()
        assert row[0] == 'testuser_updated'

================
File: utils/alert_system.py
================
# utils/alert_system.py
import logging
import asyncio
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass

logger = logging.getLogger(__name__)

class AlertSeverity(Enum):
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"

@dataclass
class AlertThreshold:
    warning: float
    critical: float
    cooldown: int  # seconds between repeated alerts

class AlertManager:
    def __init__(self, bot):
        self.bot = bot
        self.alert_history: Dict[str, datetime] = {}
        self.alert_handlers: List[Callable] = []
        self.is_running = False
        
        # Define default thresholds
        self.thresholds = {
            'query_time': AlertThreshold(warning=100, critical=500, cooldown=300),
            'cpu_usage': AlertThreshold(warning=70, critical=90, cooldown=600),
            'memory_usage': AlertThreshold(warning=80, critical=95, cooldown=600),
            'error_rate': AlertThreshold(warning=5, critical=15, cooldown=300),
            'connection_pool': AlertThreshold(warning=80, critical=95, cooldown=300),
        }

    async def start_monitoring(self):
        """Start alert monitoring"""
        if self.is_running:
            return
            
        self.is_running = True
        while self.is_running:
            await self.check_all_metrics()
            await asyncio.sleep(60)  # Check every minute

    async def check_all_metrics(self):
        """Check all monitored metrics"""
        try:
            # Get current metrics
            performance_metrics = await self.bot.db.get_performance_metrics()
            pool_status = await self.bot.db.get_pool_status()

            # Check query performance
            for query_name, metrics in performance_metrics['query_metrics'].items():
                if await self._should_alert('query_time', query_name):
                    if metrics['avg_time'] > self.thresholds['query_time'].critical:
                        await self.trigger_alert(
                            'query_performance',
                            f"Critical query performance: {query_name} ({metrics['avg_time']:.2f}ms)",
                            AlertSeverity.CRITICAL,
                            metrics
                        )
                    elif metrics['avg_time'] > self.thresholds['query_time'].warning:
                        await self.trigger_alert(
                            'query_performance',
                            f"Slow query detected: {query_name} ({metrics['avg_time']:.2f}ms)",
                            AlertSeverity.WARNING,
                            metrics
                        )

            # Check resource usage
            cpu_usage = performance_metrics['resource_usage']['cpu_avg']
            if cpu_usage > self.thresholds['cpu_usage'].critical:
                await self.trigger_alert(
                    'cpu_usage',
                    f"Critical CPU usage: {cpu_usage:.1f}%",
                    AlertSeverity.CRITICAL,
                    {'cpu_usage': cpu_usage}
                )
            elif cpu_usage > self.thresholds['cpu_usage'].warning:
                await self.trigger_alert(
                    'cpu_usage',
                    f"High CPU usage: {cpu_usage:.1f}%",
                    AlertSeverity.WARNING,
                    {'cpu_usage': cpu_usage}
                )

            # Check connection pool
            pool_usage = (pool_status['checkedout'] / pool_status['size']) * 100
            if pool_usage > self.thresholds['connection_pool'].critical:
                await self.trigger_alert(
                    'connection_pool',
                    f"Critical connection pool usage: {pool_usage:.1f}%",
                    AlertSeverity.CRITICAL,
                    pool_status
                )
            elif pool_usage > self.thresholds['connection_pool'].warning:
                await self.trigger_alert(
                    'connection_pool',
                    f"High connection pool usage: {pool_usage:.1f}%",
                    AlertSeverity.WARNING,
                    pool_status
                )

        except Exception as e:
            logger.error(f"Error in alert monitoring: {e}")

    async def trigger_alert(self, alert_type: str, message: str, 
                          severity: AlertSeverity, context: Dict):
        """Trigger an alert with given severity and context"""
        if not await self._should_alert(alert_type, message):
            return

        alert = {
            'type': alert_type,
            'message': message,
            'severity': severity,
            'timestamp': datetime.now(timezone.utc),
            'context': context
        }

        # Log alert
        log_method = {
            AlertSeverity.INFO: logger.info,
            AlertSeverity.WARNING: logger.warning,
            AlertSeverity.CRITICAL: logger.critical
        }[severity]
        
        log_method(f"Alert: {message}")

        # Notify all handlers
        for handler in self.alert_handlers:
            try:
                await handler(alert)
            except Exception as e:
                logger.error(f"Error in alert handler: {e}")

        # Update alert history
        self.alert_history[f"{alert_type}:{message}"] = datetime.now(timezone.utc)

    async def _should_alert(self, alert_type: str, key: str) -> bool:
        """Check if we should trigger an alert based on cooldown"""
        history_key = f"{alert_type}:{key}"
        if history_key not in self.alert_history:
            return True

        last_alert = self.alert_history[history_key]
        cooldown = self.thresholds[alert_type].cooldown
        return (datetime.now(timezone.utc) - last_alert).total_seconds() > cooldown

    def add_alert_handler(self, handler: Callable):
        """Add a new alert handler"""
        self.alert_handlers.append(handler)

    async def stop_monitoring(self):
        """Stop alert monitoring"""
        self.is_running = False

================
File: utils/cache_manager.py
================
# utils/cache_manager.py
import time
import logging
from typing import Any, Dict, Optional, Callable
from datetime import datetime, timedelta
from functools import wraps
import asyncio

logger = logging.getLogger(__name__)

class CacheManager:
    def __init__(self, default_ttl: int = 300):  # 5 minutes default TTL
        self.cache: Dict[str, Dict[str, Any]] = {}
        self.default_ttl = default_ttl
        self.lock = asyncio.Lock()

    async def get(self, key: str) -> Optional[Any]:
        """Get item from cache if it exists and hasn't expired"""
        if key not in self.cache:
            return None

        cache_data = self.cache[key]
        if time.time() > cache_data['expires']:
            await self.delete(key)
            return None

        return cache_data['value']

    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> None:
        """Set item in cache with expiration"""
        async with self.lock:
            self.cache[key] = {
                'value': value,
                'expires': time.time() + (ttl or self.default_ttl)
            }

    async def delete(self, key: str) -> None:
        """Remove item from cache"""
        async with self.lock:
            self.cache.pop(key, None)

    async def clear(self) -> None:
        """Clear all cached items"""
        async with self.lock:
            self.cache.clear()

    async def cleanup(self) -> None:
        """Remove expired items from cache"""
        async with self.lock:
            current_time = time.time()
            expired_keys = [
                key for key, data in self.cache.items()
                if current_time > data['expires']
            ]
            for key in expired_keys:
                self.cache.pop(key)

def cached(ttl: Optional[int] = None):
    """Decorator for caching function results"""
    def decorator(func):
        @wraps(func)
        async def wrapper(self, *args, **kwargs):
            # Generate cache key from function name and arguments
            key = f"{func.__name__}:{args}:{kwargs}"
            
            # Try to get from cache first
            cached_value = await self.cache_manager.get(key)
            if cached_value is not None:
                return cached_value

            # If not in cache, execute function
            result = await func(self, *args, **kwargs)
            
            # Store in cache
            await self.cache_manager.set(key, result, ttl)
            
            return result
        return wrapper
    return decorator

================
File: utils/db_health.py
================
# utils/db_health.py
import logging
import asyncio
from typing import Optional
from datetime import datetime, timezone
from sqlalchemy import text

logger = logging.getLogger(__name__)

class ConnectionHealthMonitor:
    def __init__(self, db_manager, check_interval: int = 60):
        self.db_manager = db_manager
        self.check_interval = check_interval
        self.last_check: Optional[datetime] = None
        self.is_running = False
        self.failed_checks = 0
        self.max_failures = 3

    async def start_monitoring(self):
        """Start connection health monitoring"""
        if self.is_running:
            return
            
        self.is_running = True
        while self.is_running:
            await self.check_connections()
            await asyncio.sleep(self.check_interval)

    async def stop_monitoring(self):
        """Stop connection health monitoring"""
        self.is_running = False

    async def check_connections(self) -> bool:
        """Check database connection health"""
        try:
            async with self.db_manager.session_scope() as session:
                await asyncio.to_thread(
                    session.execute, 
                    text('SELECT 1')
                )
            
            self.last_check = datetime.now(timezone.utc)
            self.failed_checks = 0
            logger.debug("Database connection health check passed")
            return True
            
        except Exception as e:
            self.failed_checks += 1
            logger.error(f"Database health check failed: {e}")
            
            if self.failed_checks >= self.max_failures:
                await self._handle_connection_failure()
            return False

    async def check_database(self) -> bool:
        """Public method to check database health"""
        return await self.check_connections()

    async def _handle_connection_failure(self):
        """Handle repeated connection failures"""
        logger.critical("Multiple database connection failures detected")
        try:
            # Dispose current pool and create new connections
            await asyncio.to_thread(self.db_manager.engine.dispose)
            
            # Create new engine with fresh connection pool
            self.db_manager._setup_engine()
            logger.info("Database connection pool has been reset")
            
        except Exception as e:
            logger.critical(f"Failed to recover database connections: {e}")

================
File: utils/decorators.py
================
# utils/decorators.py
import functools
import logging
from typing import Type, Union, Callable
import traceback
from datetime import datetime, timezone

logger = logging.getLogger(__name__)

def error_boundary(error_types: Union[Type[Exception], tuple] = Exception,
                  retries: int = 0,
                  log_message: str = "Error in {func_name}"):
    """
    Decorator that creates an error boundary around async functions.
    Handles errors, logging, and optional retries.
    """
    def decorator(func: Callable):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            attempts = retries + 1
            last_error = None

            for attempt in range(attempts):
                try:
                    return await func(*args, **kwargs)
                except error_types as e:
                    last_error = e
                    error_details = {
                        'function': func.__name__,
                        'error_type': type(e).__name__,
                        'error_message': str(e),
                        'timestamp': datetime.now(timezone.utc),
                        'attempt': attempt + 1,
                        'traceback': traceback.format_exc()
                    }
                    
                    logger.error(
                        log_message.format(func_name=func.__name__),
                        extra=error_details
                    )
                    
                    if attempt < attempts - 1:
                        logger.info(f"Retrying {func.__name__} (attempt {attempt + 2}/{attempts})")
                    else:
                        logger.error(f"All retries failed for {func.__name__}")
            
            # If we get here, all retries failed
            raise last_error
    
        return wrapper
    return decorator

def rate_limited(cooldown: int = 3, global_cooldown: int = 1, mod_bypass: bool = True):
    """
    Decorator to apply rate limiting to commands.
    cooldown: per-user cooldown in seconds
    global_cooldown: global cooldown in seconds
    mod_bypass: whether moderators bypass cooldowns
    """
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(self, ctx, *args, **kwargs):
            # Mods bypass cooldown if enabled
            if mod_bypass and ctx.author.is_mod:
                return await func(self, ctx, *args, **kwargs)

            can_execute, wait_time = await self.bot.rate_limiter.can_execute(
                func.__name__,
                str(ctx.author.id),
                cooldown,
                global_cooldown
            )

            if not can_execute:
                await ctx.send(f"@{ctx.author.name} Please wait {wait_time:.1f} seconds before using this command again.")
                return

            return await func(self, ctx, *args, **kwargs)
        return wrapper
    return decorator

================
File: utils/error_tracking.py
================
# utils/error_tracker.py
import logging
from datetime import datetime, timezone
import traceback
from typing import Dict, List
import asyncio
from collections import deque

logger = logging.getLogger(__name__)

class ErrorTracker:
    def __init__(self, max_errors: int = 1000):
        self.errors: deque = deque(maxlen=max_errors)
        self.error_counts: Dict[str, int] = {}
        self.lock = asyncio.Lock()

    async def report(self, error: Exception, context: Dict = None) -> None:
        """Report an error with optional context"""
        async with self.lock:
            error_type = type(error).__name__
            error_entry = {
                'type': error_type,
                'message': str(error),
                'timestamp': datetime.now(timezone.utc),
                'context': context or {},
                'traceback': traceback.format_exc()
            }
            
            self.errors.append(error_entry)
            self.error_counts[error_type] = self.error_counts.get(error_type, 0) + 1

    async def get_recent_errors(self, limit: int = 10) -> List[Dict]:
        """Get most recent errors"""
        async with self.lock:
            return list(self.errors)[-limit:]

    async def get_error_summary(self) -> Dict:
        """Get error statistics"""
        async with self.lock:
            return {
                'total_errors': len(self.errors),
                'error_counts': dict(self.error_counts),
                'recent_errors': await self.get_recent_errors(5)
            }

================
File: utils/health_checker.py
================
# utils/health_checker.py
import logging
import asyncio
from datetime import datetime, timezone
from typing import Dict, Optional
from sqlalchemy import text

logger = logging.getLogger(__name__)

class HealthChecker:
    def __init__(self, bot):
        self.bot = bot
        self.last_check = None
        self.health_status = {}
        self.is_running = False

    async def start_monitoring(self):
        """Start the health check monitoring loop"""
        if self.is_running:
            return
            
        self.is_running = True
        while self.is_running:
            await self.check_health()
            await asyncio.sleep(60)  # Check every minute

    async def stop_monitoring(self):
        """Stop the health check monitoring"""
        self.is_running = False

    async def check_health(self) -> Dict[str, bool]:
        """Run all health checks"""
        self.last_check = datetime.now(timezone.utc)
        self.health_status = {
            'database': await self.check_database(),
            'twitch_api': await self.check_twitch_api(),
            'bot_responsive': await self.check_bot_responsive()
        }
        return self.health_status

    async def check_database(self) -> bool:
        """Check database connectivity"""
        try:
            async with self.bot.db.session_scope() as session:
                await asyncio.to_thread(session.execute, text('SELECT 1'))
            return True
        except Exception as e:
            logger.error(f"Database health check failed: {e}")
            return False

    async def check_twitch_api(self) -> bool:
        """Check Twitch API status"""
        try:
            # Test a simple API call
            await self.bot.get_channel(self.bot.nick)
            return True
        except Exception as e:
            logger.error(f"Twitch API health check failed: {e}")
            return False

    async def check_bot_responsive(self) -> bool:
        """Check if bot is responsive"""
        try:
            current_time = datetime.now(timezone.utc)
            if self.last_check is None:
                return True
            
            # If last check was more than 2 minutes ago, consider unresponsive
            time_diff = (current_time - self.last_check).total_seconds()
            return time_diff < 120
        except Exception as e:
            logger.error(f"Bot responsiveness check failed: {e}")
            return False

    def get_status(self) -> Dict[str, Dict]:
        """Get current health status with details"""
        return {
            'status': all(self.health_status.values()),
            'last_check': self.last_check,
            'checks': self.health_status,
            'details': {
                'database': {
                    'healthy': self.health_status.get('database', False),
                    'connection': bool(self.bot.db.engine)
                },
                'twitch_api': {
                    'healthy': self.health_status.get('twitch_api', False),
                    'connected': bool(self.bot._connection)
                },
                'bot': {
                    'healthy': self.health_status.get('bot_responsive', False),
                    'uptime': (datetime.now(timezone.utc) - self.bot.start_time).total_seconds() if hasattr(self.bot, 'start_time') else None
                }
            }
        }

================
File: utils/monitoring.py
================
# utils/monitoring.py
import time
import logging
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from collections import deque
import psutil
import statistics

logger = logging.getLogger(__name__)

class PerformanceMonitor:
    def __init__(self, bot, history_size: int = 1000):
        self.bot = bot
        self.is_running = False
        self.history_size = history_size
        
        # Performance metrics storage
        self.command_timings: Dict[str, deque] = {}
        self.db_query_times: deque = deque(maxlen=history_size)
        self.event_processing_times: deque = deque(maxlen=history_size)
        self.memory_usage: deque = deque(maxlen=history_size)
        self.cpu_usage: deque = deque(maxlen=history_size)
        
        # Process info for resource monitoring
        self.process = psutil.Process()

    async def start_monitoring(self):
        """Start the monitoring loop"""
        if self.is_running:
            return
            
        self.is_running = True
        while self.is_running:
            await self.collect_metrics()
            await asyncio.sleep(5)  # Collect metrics every 5 seconds

    async def stop_monitoring(self):
        """Stop the monitoring loop"""
        self.is_running = False

    async def collect_metrics(self):
        """Collect current performance metrics"""
        try:
            # Resource usage
            self.memory_usage.append(self.process.memory_info().rss / 1024 / 1024)  # MB
            self.cpu_usage.append(self.process.cpu_percent())
            
            # Log if resource usage is high
            if self.memory_usage[-1] > 500:  # Warning if over 500MB
                logger.warning(f"High memory usage: {self.memory_usage[-1]:.2f}MB")
            if self.cpu_usage[-1] > 70:  # Warning if over 70%
                logger.warning(f"High CPU usage: {self.cpu_usage[-1]}%")
                
        except Exception as e:
            logger.error(f"Error collecting metrics: {e}")

    async def record_command_timing(self, command_name: str, execution_time: float):
        """Record command execution time"""
        if command_name not in self.command_timings:
            self.command_timings[command_name] = deque(maxlen=self.history_size)
        self.command_timings[command_name].append(execution_time)

    async def record_db_query(self, query_time: float):
        """Record database query execution time"""
        self.db_query_times.append(query_time)
        if query_time > 1.0:  # Warning if query takes more than 1 second
            logger.warning(f"Slow database query detected: {query_time:.2f}s")

    async def record_event_processing(self, event_name: str, processing_time: float):
        """Record event processing time"""
        self.event_processing_times.append(processing_time)
        if processing_time > 0.5:  # Warning if event processing takes more than 0.5 seconds
            logger.warning(f"Slow event processing detected ({event_name}): {processing_time:.2f}s")

    def get_metrics(self) -> Dict:
        """Get current performance metrics summary"""
        return {
            'memory_usage': {
                'current': self.memory_usage[-1] if self.memory_usage else 0,
                'average': statistics.mean(self.memory_usage) if self.memory_usage else 0,
                'peak': max(self.memory_usage) if self.memory_usage else 0
            },
            'cpu_usage': {
                'current': self.cpu_usage[-1] if self.cpu_usage else 0,
                'average': statistics.mean(self.cpu_usage) if self.cpu_usage else 0,
                'peak': max(self.cpu_usage) if self.cpu_usage else 0
            },
            'command_performance': {
                name: {
                    'average': statistics.mean(times) if times else 0,
                    'max': max(times) if times else 0,
                    'count': len(times)
                } for name, times in self.command_timings.items()
            },
            'database_performance': {
                'average_query_time': statistics.mean(self.db_query_times) if self.db_query_times else 0,
                'max_query_time': max(self.db_query_times) if self.db_query_times else 0,
                'total_queries': len(self.db_query_times)
            },
            'event_processing': {
                'average_time': statistics.mean(self.event_processing_times) if self.event_processing_times else 0,
                'max_time': max(self.event_processing_times) if self.event_processing_times else 0,
                'total_events': len(self.event_processing_times)
            }
        }

class TimingContext:
    """Context manager for timing operations"""
    def __init__(self, monitor, operation_type: str, name: str):
        self.monitor = monitor
        self.operation_type = operation_type
        self.name = name
        self.start_time = None

    async def __aenter__(self):
        self.start_time = time.monotonic()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        duration = time.monotonic() - self.start_time
        if self.operation_type == 'command':
            await self.monitor.record_command_timing(self.name, duration)
        elif self.operation_type == 'db_query':
            await self.monitor.record_db_query(duration)
        elif self.operation_type == 'event':
            await self.monitor.record_event_processing(self.name, duration)

================
File: utils/performance_monitor.py
================
# utils/performance_monitor.py
import time
import logging
import asyncio
import psutil
from datetime import datetime, timedelta, timezone
from collections import deque
from typing import Dict, List, Optional
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class QueryMetrics:
    total_time: float
    count: int
    avg_time: float
    max_time: float
    min_time: float
    last_slow_query: Optional[datetime]

class PerformanceTracker:
    def __init__(self, history_size: int = 1000, alert_threshold_ms: int = 100):
        self.history_size = history_size
        self.alert_threshold_ms = alert_threshold_ms
        
        # Query performance tracking
        self.query_history: Dict[str, deque] = {}
        self.query_metrics: Dict[str, QueryMetrics] = {}
        
        # Resource tracking
        self.cpu_usage = deque(maxlen=history_size)
        self.memory_usage = deque(maxlen=history_size)
        self.io_counters = deque(maxlen=history_size)
        
        # Bottleneck detection
        self.bottleneck_points: List[Dict] = []
        self.process = psutil.Process()

    async def track_query(self, query_name: str, execution_time: float):
        """Record query execution time and check for bottlenecks"""
        if query_name not in self.query_history:
            self.query_history[query_name] = deque(maxlen=self.history_size)
        
        self.query_history[query_name].append(execution_time)
        await self._update_query_metrics(query_name)
        
        if execution_time > self.alert_threshold_ms:
            await self._record_bottleneck(query_name, execution_time)

    async def _update_query_metrics(self, query_name: str):
        """Update query performance metrics"""
        times = list(self.query_history[query_name])
        if not times:
            return

        self.query_metrics[query_name] = QueryMetrics(
            total_time=sum(times),
            count=len(times),
            avg_time=sum(times) / len(times),
            max_time=max(times),
            min_time=min(times),
            last_slow_query=datetime.now(timezone.utc) if times[-1] > self.alert_threshold_ms else None
        )

    async def _record_bottleneck(self, query_name: str, execution_time: float):
        """Record performance bottleneck with context"""
        bottleneck = {
            'timestamp': datetime.now(timezone.utc),
            'query_name': query_name,
            'execution_time': execution_time,
            'cpu_usage': self.process.cpu_percent(),
            'memory_usage': self.process.memory_info().rss / 1024 / 1024,
            'context': await self._get_system_context()
        }
        
        self.bottleneck_points.append(bottleneck)
        logger.warning(f"Performance bottleneck detected: {bottleneck}")

    async def _get_system_context(self) -> Dict:
        """Get system context for bottleneck analysis"""
        return {
            'cpu_count': psutil.cpu_count(),
            'memory_available': psutil.virtual_memory().available / 1024 / 1024,
            'disk_io': psutil.disk_io_counters()._asdict() if psutil.disk_io_counters() else None,
            'network_io': psutil.net_io_counters()._asdict() if psutil.net_io_counters() else None
        }

    async def get_performance_report(self) -> Dict:
        """Generate comprehensive performance report"""
        return {
            'query_metrics': {
                name: {
                    'avg_time': metrics.avg_time,
                    'max_time': metrics.max_time,
                    'total_queries': metrics.count,
                    'slow_queries': sum(1 for t in self.query_history[name] if t > self.alert_threshold_ms)
                }
                for name, metrics in self.query_metrics.items()
            },
            'resource_usage': {
                'cpu_avg': sum(self.cpu_usage) / len(self.cpu_usage) if self.cpu_usage else 0,
                'memory_avg': sum(self.memory_usage) / len(self.memory_usage) if self.memory_usage else 0,
            },
            'bottlenecks': self.bottleneck_points[-10:],  # Last 10 bottlenecks
            'system_health': await self._get_system_context()
        }

    async def analyze_trends(self) -> Dict:
        """Analyze performance trends and provide recommendations"""
        recommendations = []
        
        # Analyze query patterns
        for query_name, metrics in self.query_metrics.items():
            if metrics.avg_time > self.alert_threshold_ms / 2:
                recommendations.append({
                    'type': 'query_optimization',
                    'target': query_name,
                    'reason': f'High average execution time: {metrics.avg_time:.2f}ms',
                    'suggestion': 'Consider adding indexes or optimizing query structure'
                })

        # Analyze resource usage
        if any(cpu > 80 for cpu in self.cpu_usage):
            recommendations.append({
                'type': 'resource_optimization',
                'target': 'cpu',
                'reason': 'High CPU usage detected',
                'suggestion': 'Consider implementing caching or query optimization'
            })

        return {
            'recommendations': recommendations,
            'trend_analysis': {
                'performance_degradation': self._detect_degradation(),
                'resource_pressure': self._analyze_resource_pressure()
            }
        }

    def _detect_degradation(self) -> Dict:
        """Detect performance degradation patterns"""
        degradation = {}
        for query_name, history in self.query_history.items():
            if len(history) < 10:
                continue
            
            recent = list(history)[-10:]
            older = list(history)[:-10]
            if recent and older:
                recent_avg = sum(recent) / len(recent)
                older_avg = sum(older) / len(older)
                if recent_avg > older_avg * 1.2:  # 20% degradation
                    degradation[query_name] = {
                        'recent_avg': recent_avg,
                        'historical_avg': older_avg,
                        'degradation_pct': ((recent_avg - older_avg) / older_avg) * 100
                    }
        
        return degradation

    def _analyze_resource_pressure(self) -> Dict:
        """Analyze resource usage patterns"""
        return {
            'cpu_pressure': any(cpu > 80 for cpu in self.cpu_usage),
            'memory_pressure': any(mem > 85 for mem in self.memory_usage),
            'sustained_high_load': self._check_sustained_load()
        }

    def _check_sustained_load(self) -> bool:
        """Check for sustained high resource usage"""
        if len(self.cpu_usage) < 10:
            return False
            
        recent_cpu = list(self.cpu_usage)[-10:]
        return sum(cpu > 70 for cpu in recent_cpu) >= 7  # 70% high load for 7 out of 10 samples

================
File: utils/query_profiler.py
================
# utils/query_profiler.py
import time
import logging
from functools import wraps
from typing import Optional

logger = logging.getLogger(__name__)

def profile_query(threshold_ms: Optional[int] = 100):
    """Decorator to profile query execution time"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = await func(*args, **kwargs)
                execution_time = (time.time() - start_time) * 1000
                
                if threshold_ms and execution_time > threshold_ms:
                    logger.warning(
                        f"Slow query detected in {func.__name__}: "
                        f"{execution_time:.2f}ms (threshold: {threshold_ms}ms)"
                    )
                return result
            except Exception as e:
                execution_time = (time.time() - start_time) * 1000
                logger.error(
                    f"Query error in {func.__name__}: {str(e)} "
                    f"after {execution_time:.2f}ms"
                )
                raise
        return wrapper
    return decorator

================
File: utils/rate_limiter.py
================
# utils/rate_limiter.py
import asyncio
from datetime import datetime, timedelta, timezone
from typing import Dict, Optional, Tuple
import logging

logger = logging.getLogger(__name__)

class RateLimiter:
    def __init__(self):
        self.command_cooldowns: Dict[str, Dict[str, datetime]] = {}
        self.global_cooldowns: Dict[str, datetime] = {}
        self._lock = asyncio.Lock()

    def _get_now(self) -> datetime:
        return datetime.now(timezone.utc)

    async def can_execute(
        self,
        command_name: str,
        user_id: str,
        cooldown: int = 3,
        global_cooldown: int = 1,
    ) -> Tuple[bool, Optional[float]]:
        if not command_name or not user_id:
            return True, None

        if cooldown <= 0 and global_cooldown <= 0:
            return True, None

        now = self._get_now()
        command_key = command_name.lower()

        async with self._lock:
            # Clean up old cooldowns first
            self._cleanup_old_cooldowns(now)

            # Check global cooldown first
            if global_cooldown > 0 and command_key in self.global_cooldowns:
                time_since_last = (now - self.global_cooldowns[command_key]).total_seconds()
                logger.debug(f"Global cooldown check: {time_since_last} < {global_cooldown}")
                if time_since_last < global_cooldown:
                    return False, global_cooldown - time_since_last

            # Check user-specific cooldown
            if cooldown > 0:
                if command_key in self.command_cooldowns and user_id in self.command_cooldowns[command_key]:
                    time_since_last = (now - self.command_cooldowns[command_key][user_id]).total_seconds()
                    logger.debug(f"User cooldown check: {time_since_last} < {cooldown}")
                    if time_since_last < cooldown:
                        return False, cooldown - time_since_last

            # If we get here, update cooldowns and allow execution
            if global_cooldown > 0:
                self.global_cooldowns[command_key] = now
            if cooldown > 0:
                if command_key not in self.command_cooldowns:
                    self.command_cooldowns[command_key] = {}
                self.command_cooldowns[command_key][user_id] = now

            return True, None

    async def reset_cooldown(self, command_name: str, user_id: Optional[str] = None) -> None:
        command_key = command_name.lower()
        
        async with self._lock:
            logger.debug(f"Resetting cooldown for command: {command_key}, user: {user_id}")
            logger.debug(f"Before reset - Global cooldowns: {self.global_cooldowns}")
            logger.debug(f"Before reset - Command cooldowns: {self.command_cooldowns}")
            
            # Always reset global cooldown for the command
            if command_key in self.global_cooldowns:
                del self.global_cooldowns[command_key]
            
            # Reset user-specific cooldown if user_id provided
            if user_id is not None:
                if command_key in self.command_cooldowns:
                    self.command_cooldowns[command_key].pop(user_id, None)
                    if not self.command_cooldowns[command_key]:
                        del self.command_cooldowns[command_key]
            else:
                # Reset all cooldowns for this command
                self.command_cooldowns.pop(command_key, None)

            logger.debug(f"After reset - Global cooldowns: {self.global_cooldowns}")
            logger.debug(f"After reset - Command cooldowns: {self.command_cooldowns}")

    def _cleanup_old_cooldowns(self, now: Optional[datetime] = None) -> None:
        if now is None:
            now = self._get_now()

        cutoff = now - timedelta(minutes=5)
        logger.debug(f"Cleaning up cooldowns before: {cutoff}")

        # Clean up global cooldowns
        expired_globals = [
            cmd for cmd, time in self.global_cooldowns.items()
            if time <= cutoff
        ]
        for cmd in expired_globals:
            del self.global_cooldowns[cmd]

        # Clean up user cooldowns
        for cmd in list(self.command_cooldowns.keys()):
            expired_users = [
                user for user, time in self.command_cooldowns[cmd].items()
                if time <= cutoff
            ]
            for user in expired_users:
                del self.command_cooldowns[cmd][user]
            
            if not self.command_cooldowns[cmd]:
                del self.command_cooldowns[cmd]
